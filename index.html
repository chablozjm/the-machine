



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Machine</title>

	
    <style>
	::-webkit-scrollbar {
            width: 0 !important; /* Hides vertical scrollbar by making its width zero */ 
            height: 0 !important; /* Hides horizontal scrollbar by making its height zero */
            display: none; /* Fallback for some specific cases or older versions */
        }

    /* For Firefox */
    html, body {
        scrollbar-width: none; /* Hides the standard scrollbar in Firefox */
    }

/* For Internet Explorer and Edge (older versions) */
    html, body {
        -ms-overflow-style: none; /* Hides scrollbar in IE/Edge */
    }
	    
    body {
        font-family: Arial, sans-serif;
        text-align: center;            
        margin: 0;
        padding: 0;
        background-color: #f0f0f0;
        color: #333;
        font-size: 1em;
        line-height: 1.6;
    }
	    
    .container {
        max-width: 800px;
        margin: 0px auto;
        padding: 20px;
        background-color: #fff;
        font-size: 1.25em;
	text-align: center;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
	    
        #predictionContent {
            display: none; /* Initially hidden */
        }
        h1, h2, h3 {
            text-align: center;
            color: #d76324;
        }
        p {
            margin-bottom: 1em;
        }

	a {
            color: #d76324;
	}	    

        /* Input group for label and input */
        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }

        input[type="password"] {
            width: calc(100% - 20px); /* Account for padding */
            padding: 12px 10px;
            border: 2px solid #ced4da; /* Light grey border, can be adjusted for new palette */
            border-radius: 8px;
            font-size: 1em;
            margin: 20px auto;
            box-sizing: border-box; /* Include padding and border in element's total width and height */
        }

        /* Button styling */
        button {
            background-color: #959595;
            color: white;
            padding: 14px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        button:hover {
            background-color: #7A7A7A; /* Darker grey on hover */
        }

        /* Error message styling */
        .message {
            margin-top: 20px;
            font-weight: bold;
            color: #dc3545; /* Red for error messages */
        }

        /* Styling for the loading screen */
        #loadingScreen {
            display: none; /* Initially hidden */
            min-height: 200px;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 20px;
        }

        /* Styling for the explanation screen */
        #explanationScreen {
            display: none; /* Initially hidden */
            min-height: 200px;
            justify-content: left;
            align-items: left;
	    text-align: left;
            flex-direction: column;
	}

        /* Basic spinner animation on the loading screen*/
        .spinner {
            border: 8px solid rgba(0, 0, 0, 0.1);
            border-top: 8px solid #d76324; /* Spinner color matching heading */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-top: 20px;
            margin-bottom: 20px;            
            display: flex;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .container {
                padding: 25px;
            }
            h1, h2 {
                font-size: 1.8em;
            }
            button {
                padding: 12px 20px;
                font-size: 1em;
            }
            input[type="password"] {
                padding: 10px 8px;
            }
            .spinner {
                width: 40px;
                height: 40px;
                border-width: 6px;
            }
        }

        /* --- Box Styling --- */
        .interaction-box {
            text-align: center;
            margin: 80px 0; /* Vertical spacing between boxes and content */
            padding: 40px 20px;
            background-color: #e9e9e9; /* Grey box */
            border-radius: 8px;
            font-size: 1.5em;
            font-weight: bold;
            color: #555;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none; /* For Safari */
            -moz-user-select: none; /* For Firefox */
            touch-action: pan-y; /* Allow vertical scrolling, prevent horizontal or zoom on touch */
            position: relative;
        }

        /* --- White Gaps --- */
        .white-gap {
            height: 100vh;
            background-color: #fff;
            margin: 0;
            padding: 0;
        }

        /* --- Generic Content / Filler --- */
        .generic-content {
            margin-top: 50px;
            margin-bottom: 50px;
            padding: 20px;
            background-color: #f8f8f8;
            font-size: 1em;
            border-radius: 5px;
            text-align: center;
        }

        .scan-finger-button {
            width: 100px; /* Fixed width for a perfect circle */
            height: 100px; /* Fixed height for a perfect circle */
            border-radius: 50%; /* Makes it round */
            padding: 0; /* Remove padding as there's no text */
            display: flex; /* Use flex to center any potential icon/inner elements */
            justify-content: center;
            align-items: center;
            font-size: 0; /* Hide any default text if present */
            background-color: #e0e0e0; /* Grey background */
            border: 5px solid #d76324; /* Orange border */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); /* Soft shadow */
        }

        .scan-finger-button:hover {
            background-color: #d0d0d0; /* Slightly darker grey on hover */
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .scan-finger-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Scan progress text */
        #scanProgressText {
            margin-top: 15px;
            font-weight: bold;
            color: #d76324;
        }

        /* Progress bar styling */
        .progress-bar-container {
            width: 80%;
            background-color: #e0e0e0;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 20px;
            height: 20px;
        }

        .progress-bar-fill {
            height: 100%;
            width: 0%; /* Initial width */
            background-color: #d76324;
            border-radius: 5px;
            transition: width 0.1s linear; /* Smooth transition for progress */
        }
	    
        /* Warning message styling */
        #warningMessage {
            color: #dc3545; /* Red color for warning */
            font-weight: bold;
            font-size: 1.2em;
            margin-top: 20px;
            visibility: none; /* Hidden by default */
        }

        .red {
           color: #dc3545;
	}
	    
        /* Blinking class for messages */
        .blink {
	    font-size: 1.5 em;
	    font-weight: bold;
            animation: blink 0.4s infinite alternate;
        }

        @keyframes blink {
            0% { opacity: 1; }
            100% { opacity: 0.2; }
        }



        /* Responsive adjustments */
        @media (max-width: 600px) {
            .container {
                padding: 25px;
                font-size: 1.1em; /* Slightly smaller base for container on mobile */
            }
            h2 {
                font-size: 1.6em; /* Adjust heading size */
            }
            p {
                font-size: 1em; /* Adjust paragraph size */
            }
            button { /* General button styling */
                padding: 12px 20px;
                font-size: 1.2em;
            }
            .scan-finger-button { /* Specific scan button styling on mobile */
                width: 80px;
                height: 80px;
            }
        }
        #loadingTextBox {
            height: 15vh;
	}

        /* Styles for the round button */
        .round-button {
            width: 50vw; /* Button width is half the viewport width */
            height: 50vw; /* Button height is half the viewport width to keep it round */
            max-width: 200px; /* Max width for desktop screens */
            max-height: 200px; /* Max height for desktop screens */
            border-radius: 50%; /* Make it perfectly round */
            background-color: #d76324; /* Indigo 600 from Tailwind palette */
            color: white; /* White text color */
            cursor: pointer; /* Indicate it's clickable */
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, border-color 0.2s ease-in-out; /* Smooth transitions for hover/active states and border color */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); /* Soft shadow for depth */
            outline: none; /* Remove outline on focus */
            position: relative; /* Needed for positioning the spinner pseudo-element */
            overflow: hidden; /* Hide parts of the spinner that go outside the button if needed */

            /* Default state: dark grey border */
            border: 8px solid #4A4A4A; /* Dark grey border */
        }

        /* Styles for the button when it's active (pressed) */
        .round-button:active {
            background-color: #b74304; /* Darker indigo when pressed */
            transform: scale(0.98); /* Slightly shrink on press for visual feedback */
        }

        /* Spinner animation definition */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Spinner effect for the button when the 'spinning' class is applied */
        .round-button.spinning {
            border-top-color: #d1d5db; /* Dark grey top border */
            border-bottom-color: #4A4A4A; /* Dark grey bottom border */
            border-left-color: #4A4A4A; /* Light grey for left (Tailwind gray-300) */
            border-right-color: #4A4A4A; /* Light grey for right (Tailwind gray-300) */
            animation: spin 0.5s linear infinite; /* Apply the spin animation */
        }

        /* Container for the progress bar */
        .progress-container {
            width: 80vw; /* Progress bar width is 80% of viewport width */
            max-width: 320px; /* Max width for desktop screens (80% of 400px max container) */
            height: 30px; /* Fixed height for the progress bar container */
            background-color: #E0E7FF; /* Light indigo background */
            border-radius: 8px; /* Rounded corners for the container */
            overflow: hidden; /* Hide any overflow from the progress bar fill */
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1); /* Inner shadow for depth */
            margin-bottom: 20px; /* Space between progress bar and button */
            margin-left: auto; /* Center the progress bar */
            margin-right: auto; /* Center the progress bar */
        }

        /* The actual progress bar fill */
        .progress-bar {
            height: 100%; /* Take full height of its container */
            width: 0%; /* Initial width is 0% */
            background-color: #b74304; /* Dark Orange */
            border-radius: 8px; /* Rounded corners for the fill */
            display: flex; /* Use flexbox to center text inside the bar */
            justify-content: center; /* Center text horizontally */
            align-items: center; /* Center text vertically */
            color: white; /* White text color */
            font-weight: bold; /* Bold text */
            transition: width 0.1s linear; /* Smooth transition for width changes */
            white-space: nowrap; /* Prevent text from wrapping */
            overflow: hidden; /* Hide text if it overflows */
        }


	    
    </style>














	    
    </style>
</head>
<body>

    <div id="passwordScreen" class="container">
        <h1>Welcome to<br>The Machine</h1>
        <div class="input-group">
            <label for="password">Predicting Your Future Since 1999</label>
            <input type="password" id="password" placeholder="" autocomplete="current-password">
        </div>
        <button id="generatePredictionButton">Generate Prediction</button>
        <p class="message" id="errorMessage"></p>
        <hr style="border: none;">
        <hr style="border: none;">	
	<p>Created and maintained by <a style="color: #000000#;" href="https://jmc-magic.com">J.M. Chabloz</a>, with the help of the greatest consortium of magicians and visionaries that ever came together:</p>	    
	<div id="contributors">
	</div>
        <hr style="border: none;">
        <hr style="border: none;">		    
        <a href="https://jmc-magic.com">jmc-magic.com</a>
        <hr style="border: none;">
        <hr style="border: none;">	    	    		    
    </div>

    <div id="loadingScreen" class="container">
        <h1 id=loadingTitle>Scanning</h1>
	<div id = "loadingTextBox">   
            <p id="loadingText">Press and hold the button to initiate scan.</p>
	</div>
	<div id="loadingSpinner" class="spinner"></div>
	<div id="loadingBarContainer" class="progress-bar-container">    
            <div id="loadingBar" class="progress-bar-fill"></div>
        </div>
	<p id="loadingProgressText">Scan Progress: 0%</p>
        <button id="loadingButton" class="round-button"></button>
        <div class="white-gap"></div> 			    
    </div>

    <div id="predictionContent" class="container">    
        <h1>Prediction Completed</h1>
        <hr style="border: none;">
        <hr style="border: none;">        
	<div id="stats">
            <p>Prediction generated in <span id="nrOfSeconds"></span> s.</p>
            <hr style="border: none;">
            <hr style="border: none;">
            <div id="funnyStats">
                <p><span id="crystalBalls"></span> digital crystal balls analyzed.</p>
                <p><span id="teaLeaves"></span> algorithmic tea leaves interpreted.</p>
                <p><span id="tarotCards"></span> decks of virtual tarot cards shuffled.</p>
                <p><span id="sheepEntrails"></span> electronic sheep's entrails recreated and observed.</p>
            </div>
	</div>
        <div class="white-gap"></div>
	    <div id="stopSign" style="font-size: 4em">
            STOP
        </div>
        <p>Prediction starts below.</p>
        <div class="white-gap"></div>        
	<div class="interaction-box" id="boxr1">
            You will pick HEAD
        </div>
        <div class="white-gap"></div>        
	<div class="interaction-box" id="boxr2">
            You will pick HEAD
        </div>
        <div class="white-gap"></div>
	<div class="interaction-box" id="boxr3">
            You will pick HEAD
        </div>
        <div class="white-gap"></div>
	<div class="interaction-box" id="boxr4">
            You will pick HEAD
        </div>
        <div class="white-gap"></div>        
        <div id = finalStuff>
	    <div class="interaction-box">
                ...and you will pick TAIL...
            </div>
            <div class="white-gap"></div>             
	        <div class="interaction-box">
                ...and then HEAD again...
            </div>            
            <div class="white-gap"></div>             
	    <div class="interaction-box">
                You will change your mind several times in your head...
            </div>                    
            <div class="white-gap"></div>             
	    <div class="interaction-box">
                ...but in the end...
            </div>               
            <div class="white-gap"></div>             
	    <div class="interaction-box">
                ...you will choose...
            </div>
            <div class="white-gap"></div>
            <div class="interaction-box" style="font-size: 4em;">
                TAIL
            </div>
        </div>

        <div class="generic-content">
            <p>Free will is an overrated concept.</p>
            <hr style="border: none;">
            <hr style="border: none;">
            <p><i>Thank you.</i></p>
            <hr style="border: none;">
            <hr style="border: none;">		
            <a href="https://jmc-magic.com">jmc-magic.com</a>
        </div>
    </div>

    <div id="explanationScreen" class="container">
        <h1>Instructions</h1>
	<p>Welcome to the secret area of this website. Here you will find the instructions to perform this trick for your audience.</p>
	<h3>In a nutshell, what is this trick?</h3>
	<p>This trick is a strong piece of mentalism with un unconventional hook.</p>
	<p>From the point of view of the spectator, what happens is that the magician gives them a web address to connect to with their mobile phone. Once they reach the page, the magician gives them a password, they type it in, they press a button and a prediction is generated.</p>
	    <p>The magician explains that this prediction contains four separate HEAD / TAIL predictions for four mental coin tosses (free HEAD / TAIL choices). Three times in  row, the spectator announces their choice - HEAD or TAIL - the magician asks them to scroll down in the prediction page, and, each and every time, the prediction on the page matches their free choice.</p>
	<p>The fourth time, the magician announces them that, to remove all doubts about cheating, this time they are not even going to announce their choice out loud, it will just exist in their head. They make their choice, they scroll down the page, and, incredibly, the prediction matches again.</p>
	<p>Features:</p>
	<ul>
	<li>No sleight of hand</li>
	<li>No fancy technology, works in principle on any modern mobile</li>
	<li>The method is well protected and cannot be discovered by generating new predictions or inspecting the page source.</li>
	<li>perfect EDC: you don't need to supply anything, since you will use the spectator's mobile</li>
	<li>could even be performed remotely over a video-link, since you never come near the spectator's phone</li>
	</ul>
	<h3>In a nutshell, what is the method?</h3>
	<p>Timers! For the first three reveals, every time that the spectator announces their pick, you either let them scroll down immediateley to the next reveal, or you talk for a while and delay the scrolling. After a 20 seconds delay, the text on the reveal changes.</p>
	<p>The last reveal, in which they do not even announce their choice out loud, is based on the combination of a timer, clever wording and multiple outs. When the spectator scrolls down to the fourth reveal, it might or might not match their mental pick. If it matches, a clever psychological trick will make the spectator stop scrolling until all what comes after the reveal is deleted by a timer expiration. If it does not match, you ask them to just continue scrolling, and they will discover that, actually, what they thought was a wrong reveal was just a part of a longer reveal, that ultimately matches their choice.</p>
        <h3>What is the password to activate the machine?</h3>	  
	<p>The password is <strong>cgmcmj</strong>. It is case-insensitive, so it doesn't matter whether or not some or all letters are written in capitals. The password is "jmc magic" written backwards and with no vowels, so you can remember it easily. You should not tell this to your audience, though. Just tell them the letters, one by one, and let them enter them in the password field.</p>
<p>The main reason why there is a password system on the page is to prevent the spectator from reloading the page and generating new predictions once your performance is finished. And that is also the reason why the password is relatively complex: if the password was a simple word, like "future", it would be easy for the spectator to remember it. After your performance, they would be able to reload the page, generate a new prediction, and gain a significant, even if uncomplete, insight on how this trick works.</p>
	<p>By asking the spectator to add letters and numbers at the end of the password, you can add a few modifiers that change some parameters of the trick to better suit different performers (for example, you can control the durations of the timers). This is discussed in a later section on modifers.</p>
        <h3>How is the trick performed?</h3>
	<p>You are of course free to come out with your own presentation for the trick, but I suggest to begin by talking to your audience about "The Machine", an experimental magical machine to predict the future, created by a consortium of magicians. You give them the website and they navigate to it with their mobile phones. You could even print yourself out a sticker with a QR code, if you prefere. Feel free to tell the spectator that you also recently did some consultancy on the project, and that, as a result, you were given the password to generate predictions.</p>
<p>Explain that predicting the future is extremely hard, but that, after years of improvements, the machine is now able to predict up to four "mental coin tosses" (mental HEAD / TAIL choices). If you and the spectator are in the right mood, you can fill in with funny details: "in the early 2000s, before my time, they could predict one coin toss 80% of the time, and that was all, but then the machine kept improving... If I remember well, 2012 was the first time they could consistently get two mental coin tosses right, which was a big thing in the magic community... Now they are up to four."</p>
<p>Tell the spectator that, after the prediction is generated, they will be asked four times to choose "HEAD or TAIL" in their head, and that the machine's prediction will always match their choice.</p>
<p>Once it is time to continue, give the password to the spectator (append modifiers at the password end if you so desire, to personalize the trick). Do not say "the password is jmcmagic written backwards without vowels", just give them the letters one by one. You do not want them to remember the password afterwards.</p>
<p>Hold on for 11 seconds, while the machine "does its work". You can talk about how "nobody really understands how the machine really works - so many talented magicians have come together to build it, and everyone has only knowledge about their own little part, since everyone is so secretive. This creates hype, and hopefully makes the spectator curious and invested in what's going on.</p>
<p>Once the prediction page appears, take your time before continuing.</p>
<p>It is very important, at this point, to explain to the spectator that the page contains the predictions, and that they will have to scroll down to see them. Tell them very clearly to scroll down slowly, because you want to reveal the predictions one by one, and you don't want them to see, by mistake, a prediction meant for later.</p>
<p>If the spectator scrolls down the page without being careful, the trick will fail - you do not want that to happen. There must be hype and tension, the spectator cannot be too relaxed, or they might just casually scroll down after making their choice.</p>
<p>To mitigate this, if you have a table, ask the spectator to lay their mobile flat on the surface, so "we can all see what's going on". This way, scrolling requires a more unnatural and unfamiliar motion compared to when the mobile is in their hand, and they will be more unlikely to just casually scroll. Also, having the mobile lying flat, with everyone's eyes on it, will make the reveal seem more "serious", pushing the spectator to scroll slowlier and more carefully.</p> 
<p>The other mitigation you can use, is asking the spectator to look you in the eyes when making their mental coin tosses. This way, they will necessarily have to lift their eyes from their mobile, and, again, this will prevent them to casually scrolling down after making their choice.</p>
<p>Still, if you sense that the spectator is not trustable and might casually scroll before you tell them to, then it is probably best that you get the mobile phone in your own hands and do the scrolling yourself. It's a little less strong, but it is much safer. If you choose to go down this route, the spectator will probably not object to you getting their mobile out of their hands, since at this point they do not know anything about how the prediction page is structured, and they might think that reading the predictions is a complex operation, for which you are needed. They still don't know that it's just a matter of scrolling down, at this point.</p>
<p>One other thing that you can optionally do, at this point, is to ask the spectator to turn off the wi-fi and to put their mobile in airplane mode to "isolate it from the world and prevent anyone to enter their mobile to change the prediction". However, I would recommend against doing that, because it interferes with the flow of magic and introduces unnecessary suspicion, with the exception of when performing remotely to someone over a video-link. On a video link, maybe the spectator might think that you are secretely sending information to their mobile, and asking them to put their mobile on airplane mode might be a good way to appease their worries.</p>
<p>There is some funny text under the header of the prediction page - text about crystal balls, tea leaves, tarot cards and sheeps' entrails. If you don't like it, consider activating "serious mode" by appending the letter "s" to the password you give your spectator. You can point out to the spectator that these are all code words, to indicate different parts of the machine's prediction algorithm - the magicians in the consortium are very secretive and have a twisted sense of humor, apparently!</p>
<p>Once you are done with talking and exploring the top of the page, it's time to start scrolling. Ask your spectator to scroll down to the STOP sign.</p>
<p>As soon as the STOP sign appears on the screen, the first timer starts. Now, if they scroll down to the first reveal within 20 seconds, the reveal will say "You will pick HEAD". If it takes them longer than that, the reveal will say "You will pick TAIL".</p>
<p>Note that, as soon as the first reveal appears on the screen even for a fraction of a second, it will be locked forever. All reveals on the page work in this way, which ensures that reveals do not ever change once they are seen by the spectator. This guarantees that, from the point of view of the spectator, the page will always look like a static page containing just formatted text and no weird, changing elements.</p>	    
<p>Ask the spectator to look you in the eyes as they make and announce their choice: HEAD or TAIL.</p>
<p>If they say "HEAD", just calmly ask them to scroll down to the first reveal. This might be a good time to reiterate to please scroll slow, so they don't accidentally show the second reveal.</p>
<p>If they say "TAIL", then it is time to talk, in order to delay their scroll. My suggestion, for every time you have to talk and gain time, is to talk about the fact that, based on statistics, the spectator's choice is the less common option among all the ones that were available. On the first reveal, tell them that you just read the statistics from The Machine, and saw that actually TAIL is chosen around 43% of the time, while HEAD is chosen 57% of the time. Tell the spectator that this is maybe counter-intuitive. Most would think that, when given a binary choice, most people would go for the second option in order to try tricking the machine. Or you can mention that there are other famous studies coming to similar conclusions. Whatever. Just babble for a while, then pause, create hype - you are not on a timer and can take your time - and finally ask the spectator to scroll down slowly to the first reveal.</p>
<p>Once the first reveal appears, the second reveal timer starts automatically.</p>
<p>Once again, ask the spectator to look you in the eyes and make their choice.</p>
<p>Again, if they pick HEAD, tell them to scroll down. You have 20 seconds, so there is no need to look suspicious by being too much in a hurry.</p>	    
<p>If they choose TAIL, again, you have to talk to delay their scroll. They either chose TAIL twice, or they chose HEAD and then switched to TAIL. My suggestion is that you discuss how the action they took (same choice twice, or choice switch), is the most uncommon based on the statistics. If, for example, they choose two tails in a row, tell them that, based on the statistics, 58% of the people always change their choice when making two mental coin tosses in a row. Just like for reveal 1, talk about how other studies are confirming this, etc. After you babble for 20 seconds, pause, create some hype and then ask your spectator to scroll down.</p>	    	    
<p>Once the second reveal appears on the screen, the third timer starts automatically.</p>	  
<p>Repeat the procedure for the third time: ask them to look you in the eyes and make their choice. Based on the choice they make, either ask them to scroll directly down, or talk for a while about statistics, or - if you so prefere - about how hard it is to predict a person's choice, and about how amazing the machine actually is.</p>	  
<p>A potential problem that might occur, once in a while, is that a spectator chooses HEAD, but you get interrupted by something during the performance and too much time passes. There is an emergency procedure to recover from this, which you can read about in a later section on the emergency maneuver.</p>
<p>Also, if you want your trick to be as hard to backtrack as possible, you can decide to perform your trick in "inverted mode", by adding "i" at the end of the password you provide to the spectator. In this case, the second reveal is inverted: it will be TAIL if you scroll immediately, and HEAD if you wait. The idea behind this is that the spectator will not be able to identify the pattern "waiting equals TAIL" because it is not consistent in this mode. You can read more about in the section about modifers.</p>
<p>Once you reach the third reveal, you are not on a timer. You can therefore take your time to talk to the spectator about the fantastic feat of foresight that the machine just pulled off. Then, talk about the final step. To prove beyond any reasonable doubt that the machine really works, this time the spectator will not even tell out loud what their choice is - they will pick a value and the value will just stay in their mind. It is important that you ask them to do their last choice in a very specific way: you want them to "pick a value in their head", then "switch and pick the other one" and then "switch again and pick the other one, and then the other one, and then the other one, and so on and so on". Tell them you want them to continue switching their pick for a while, and then make up their mind and stop switching. Explain them that this procedure will ensure that the final choice is "as random as possible". And tell them that you don't want them to say anything out loud about their choice: the choice must be just in their head.</p>
<p>Let them do their choice based on this procedure. When they are done, you can create some more hype by pointing out how unbelievable it would be for the machine to pull even this last prediction off, and then tell them to scroll down. By this point, they should have understood that they schould scroll slowly. The fourth reveal always says "You will pick HEAD". Once it comes into view, a fourth and final 20 seconds timer is started. At this point, one of two things will happen.</p>
<p>The first possibility is that, when the fourth reveal comes into view, the spectator will say "No, that's wrong" because they had chosen TAIL in their head. Without losing one beat, just tell the spectator "Scroll down, I think the prediction is not finished.". And as the spectator scrolls down, several predictions will come into view, one after the other. They will say: "...and then you will pick TAIL..." "...and then HEAD again..." "You will change your mind several times in your head..." "...But in the end..." "...You will choose..." "TAIL". And then the page will end. This whole series of reveals will make sense if you have used the correct procedure when asking the spectator to make their final choice. The initial "wrong" reveal will be considered by the spectator to just be "The Machine pulling a little joke on them, by pretending it got the prediction wrong when it actually got it right". At this point, the full page content will be absolutely fixed and never change again. The spectator is free to scroll up and down the page as they please, and will not see anything suspicious. They can reload the page, but they will be presented again with the initial password page and, unless they remember the password, they will not be able to regenerate a prediction and investigate the method.</p>
<p>If the spectator had chosen HEAD in their head and the reveal matches, they will be amazed and freak out. Tell them to stop there and don't go further with their scroll, because "there is a final prediction at the bottom of the page, which we will get to later". Now take your time to talk about what just happened: the machine just pulled off four guesses in a row, and the last one was even more amazing because the chosen value existed only in the spectator's head, so cheating was out of the question! Be sure to talk for more than 20 seconds - this should be easy to pull off, given the miracle that the spectator just witnessed. When you are sure that 20 seconds are gone, tell the spectator "Ok, look, there is one last reveal on the bottom of this page, it's one single word. Do you have any idea what that word is?" Hopefully they will answer "No". Tell them to scroll down, and surely enough, the word at the bottom of the page says "NO". The trick then concludes on this joke. The reason why the joke is important, is that you need an excuse for them not to scroll down immediately when the fourth reveal comes into view. If the last joke was not there, it would be extremely suspicious for you to ask them not to scroll any further when they reach the fourth reveal, but the suspicion is removed by the presence of the joke, which gives you a reason to stop their scroll. If they do not answer "No" to your last question, answering perhaps "I don't know", or something similar, no worries. Do not push them further to say "no", just tell them to scroll down and laugh with them, as you tell them that, obviously, the machine is still not perfect, and how they are the first person who didn't answer "No" to that question, managing to fool the machine at the last second. This, hopefully, will end the trick on a positive and good note.<p>	    
<h3>Can't the spectator just look at the page code with their browser and understand the secret?</h3>	    
<p>No, the page is obfuscated. If you try to inspect the source code of the page, you will just see a nonsensical mess. Code obfuscation is a procedure that takes human-readable code and transforms it into a code that does exactly the same thing, but is very hard to read. This means that the spectator cannot inspect the source code to understand the password, cannot inspect the source code to read the instructions you are reading now, cannot inspect the source code and see how the page works. Even for a determined and expert coder, armed with the right tools, deobfuscating this page would be a complex and time-consuming operation. Not impossible, but hard enough to make this be a non-concern.</p>
<p>Incidentally, the fact that the page is obfuscated is not suspicious in itself, since obfuscation is also a common technique to protect a webpage from unwanted modifications: without obfuscation, it would be simple for anyone to edit the source code of the page to show them as authors, and copy the page to their personal website. This is much harder to do with an obfuscated page. If someone wanted to remove the jmc-magic attribution from anywhere in this webpage and copy it to their website, they would need to deobfuscate the page first, which would be a very complex and costly operation.</p>
<h3>Will this work on any mobile phone?</h3>	    
<p>The page does not use any fancy technology, just standard webpage scripting (javascript) that should work on any browser from any reasonably modern mobile operating system.</p>
<h3>What is the emergency maneuver?</h3>
<p>The emergency maneuver is your insurance card. This trick is based on a timer. The first three reveals will show "You will pick HEAD" if they appear on screen before their timer runs out, or "You will pick TAIL" if they appear on screen after their timer has run out. You might, once upon a time, encounter an unpleasant situation in which the timer has run out, and you know that, as soon as the spectator scrolls down, the wrong reveal will be shown. For example, maybe on the first reveal, after you asked the spectator to make their choice, you got interrupted by someone who absolutely needed to recount an annoying anecdote. Once you could finally go back to the trick, you hoped that the spectator would choose TAIL, but, sure enough, their choice was HEAD.</p>
<p>This sounds like a hopeless situation, but, luckily, the emergency maneuver can save you. At any time you have at most one timer-sensitive reveal whose timer has started but that hasn't been shown yet. You can reset the reveal to its before-the-timer value by scrolling back up to the top of the page. So, if you encounter this situation, tell the spectator: "look, I will show you something cool, can you scroll back up to the top of the page?". The spectator will scroll up, and then you will point out any number that appears on screen. Maybe the number of crystal balls, or the number of tea leaves. If you are in serious mode, point out the number of seconds it took to generate the prediction. Explain to the spectator that, although there are many parts of the machine that you don't understand, you know that that number, when it is even (or odd) always shows that the first reveal is "HEAD". Now let the spectator scroll down to the first reveal, and, sure enough, it will say "You will pick HEAD".</p>
<h3>What are the modifiers?</h3> 
<p>Magicians are all different, and, to accomodate different preferences, a few personalization opportunities have been introduced in this trick. These personalization opportunities, or "modifiers", are accessed by adding characters and numbers at the end of the password field. Three different modifiers are allowed, and can be combined. When combining modifiers, just append them in any order you want at the end of the password. Letters are case-insensitive and can be written in capital or small letters. Of course, do not mention to your spectator that these are modifers, treat the modifer letters as if they were a regular part of the password.</p>
<p>Appending an "s" at the end of the password will cause the machine to operate in "serious mode". The loading screen will report "Generating Prediction" instead of "Generating Prophecy" and the sentence "our algorithms are consulting the cosmic data streams" will be omitted. Once the prediction is generated, the "funny statistics" text about crystal balls, tea leaves, tarot cards and sheep's entrails will also be omitted. It's a mode designed for people with a more serious performance style, which could be put off by the comedy.</p>
<p>Appending an "i" at the end of the password will cause the machine to operate in "inverted mode". Although I think this is just a minor concern, it might be possible for some spectator to notice that every time the magician talks before the scroll, the reveal says "TAIL". Note however that this is not the case for the fourth reveal, just for the first three. But, anyway, to be as untrackable as possible, in inverted mode the second reveal is inverted: it will say TAIL if you scroll immediately, and HEAD if you wait.</p>	
<p>Appending a two digit number between 10 and 99 at the end of the password will override the default 20 seconds timer with the value that has been input, to suit different magicians' preferences. If, for example, the number 35 is appended at the end of the password, then all timers will run for 35 seconds instead of 20.</p>
<p>As an example, telling the spectator that the page password is "cgmcmj25s" will activate serious mode and use 25 seconds timers.</p>
<h3>What if the trick fails?</h3> 
<p>The webpage is designed in such a way that it should never catastrophically fail by exposing the trick - no reveal will ever change in front of the spectator's eyes. The worst thing that can happen is a wrong prediction.</p>
<p>If this happens, do not hesitate to put the blame on me and/or the other members of the consortium! "Hush!", say, "they really need to improve this machine!" Switch to some other trick, and show how your methods actually work better than the machine.</p>
<p>In other words, the fact that the author trick is clearly stated on the first page can be an advantage in case of failure: do not hesitate to blame him (me) for failures :)</p>
<h3>I found a bug!</h3>
<p>Sorry :-/ Please contact me at chablozjm@gmail.com</p>
        <hr style="border: none;">
        <hr style="border: none;">		    	    		    
    </div>

	
    <script>

document.addEventListener('DOMContentLoaded', function() {
	    
        // --- Configuration ---
        const BASE_PASSWORD = 'cgmcmj';        
        let delayTime = 20 * 1000;	    

        // --- Get DOM Elements ---
        const passwordScreen = document.getElementById('passwordScreen');
	const loadingScreen = document.getElementById('loadingScreen');
        const explanationScreen = document.getElementById('explanationScreen');	
        const predictionContent = document.getElementById('predictionContent');
        const passwordInput = document.getElementById('password');
        const generateButton = document.getElementById('generatePredictionButton');
        const errorMessage = document.getElementById('errorMessage');        
        
        /* serious mode*/
        const funnyStats = document.getElementById('funnyStats');            
        const crystalBallsSpan = document.getElementById('crystalBalls');
        const teaLeavesSpan = document.getElementById('teaLeaves');
        const tarotCardsSpan = document.getElementById('tarotCards');
        const sheepEntrailsSpan = document.getElementById('sheepEntrails');  
        const nrOfSecondsSpan = document.getElementById('nrOfSeconds');

        /* inverted mode */
	let invertedMode = false;
	    
        /* reveal areas */
        const stopSign    = document.getElementById('stopSign');
        const revealArea1 = document.getElementById('boxr1');
        const revealArea2 = document.getElementById('boxr2');
        const revealArea3 = document.getElementById('boxr3');
        const revealArea4 = document.getElementById('boxr4');
        const finalStuff  = document.getElementById('finalStuff');                       
            
        /* lock reveals */
        let stopSignReached = false;
        let reveal1Locked = false;
        let reveal2Locked = false;
        let reveal3Locked = false;
        let reveal4Reached = false;
        let finalStuffLocked = false;

        /* emergency meneuver */	
	let reveal1Going = false;
	let reveal2Going = false;
	let reveal3Going = false;

	/* loading screen */
        const loadingTitle        = document.getElementById('loadingTitle');	
	const loadingText         = document.getElementById('loadingText');	
	const loadingSpinner      = document.getElementById('loadingSpinner');
	const loadingBarContainer = document.getElementById('loadingBarContainer');	
	const loadingBar          = document.getElementById('loadingBar');	
	const loadingProgressText = document.getElementById('loadingProgressText');
	const loadingButton       = document.getElementById('loadingButton');	
        let loadingProgress = 0; // Current progress value (0-100)
        let loadingIntervalId = null; // Stores the ID of the setInterval timer
        const loadingProgressIncrement = 1; // How much progress increases per step
        const loadingIntervalTime      = 500; // Milliseconds between each step (e.g., 20ms means 50 updates per second)

	
        /* Add the contributors list */
        async function loadExternalHTML(url, targetElement) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const htmlText = await response.text();
                targetElement.innerHTML = htmlText;
                console.log(`Successfully loaded ${url}`);
            } catch (error) {
                console.error('Error loading external HTML:', error);
                targetElement.innerHTML = '<p style="color: red;">Failed to load content.</p>';
            }
        }	
	const contributors  = document.getElementById('contributors'); 
        loadExternalHTML('contributors.html', contributors);
	    
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        function getRandomFloat(min, max, decimals) {
            const str = (Math.random() * (max - min) + min).toFixed(decimals);
            return parseFloat(str);
        }
	    
        crystalBallsSpan.textContent = getRandomInt(25, 59);
        teaLeavesSpan.textContent = getRandomInt(400, 799);
        tarotCardsSpan.textContent = getRandomInt(30000, 49999).toLocaleString('en-UK');
        sheepEntrailsSpan.textContent = getRandomInt(3, 9);
        nrOfSecondsSpan.textContent = getRandomFloat(10.00, 10.99, 2).toLocaleString('en-US', {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
            
        /* observer, to determine when stuff becomes visible */
        const options = {
            root: null, // The viewport is the root
            rootMargin: '0px', // No margin around the root
            threshold: 0.01 // Trigger when even 1% of the target is visible
        };

	/* checking when the stop sign becomes visible*/
        const lockRevealStop = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !stopSignReached) {
		    reveal1Going = true;
                    setTimeout(setTail1, delayTime);                             
                    stopSignReached = true;
                    console.log('The stop sign became visible');
                }
            });
        };
        const observerStop = new IntersectionObserver(lockRevealStop, options);
        // Start observing the target div
        observerStop.observe(stopSign);   

        /* checking when reveal 1 becomes visible*/	    
        const lockReveal1 = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !reveal1Locked) {
		    reveal2Going = true;
                    setTimeout(setTail2, delayTime);                             
                    reveal1Locked = true;
                    reveal1Going = false;			
                    console.log('Reveal 1 is locked because Reveal 1 became visible');
                }
            });
        };
        const observer1 = new IntersectionObserver(lockReveal1, options);
        observer1.observe(revealArea1);            
            
        /* checking when reveal 2 becomes visible*/
        const lockReveal2 = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !reveal2Locked) {
		    reveal3Going = true;
                    setTimeout(setTail3, delayTime); 
                    reveal2Locked = true;
                    reveal2Going = false;			
                    console.log('Reveal 2 is locked because Reveal 2 became visible');
                }
            });
        };
        const observer2 = new IntersectionObserver(lockReveal2, options);
        observer2.observe(revealArea2); 
            
        /* checking when reveal 3 becomes visible*/
        const lockReveal3 = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !reveal3Locked) {
                    reveal3Locked = true;
		    reveal3Going = false;
                    console.log('Reveal 3 is locked because Reveal 3 became visible');
                }
            });
        };
        const observer3 = new IntersectionObserver(lockReveal3, options);
        observer3.observe(revealArea3);             

        /* checking when reveal 4 becomes visible*/
        const reachedReveal4 = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !reveal4Reached) {
                    reveal4Reached = true;
                    setTimeout(deleteFinalStuff, delayTime);                         
                    console.log('Reveal 4 became visible');
                }
            });
        };
        const observer4 = new IntersectionObserver(reachedReveal4, options);
        observer4.observe(revealArea4);             
            
        /* checking when final stuff becomes visible */
        const reachedFinalStuff = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !finalStuffLocked) {
                    finalStuffLocked = true;                         
                    console.log('Final Stuff is now locked because it became visible');
                }
            });
        };
        const observerFinal = new IntersectionObserver(reachedFinalStuff, options);
        observerFinal.observe(finalStuff);  

        /* checking when the stats becomes visible */
	/* to enable the emergency maneuver */
        const scrolledToStats = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && reveal1Going) {
		    reveal1Going = false;
		    revealArea1.innerHTML = 'You will pick HEAD';
                    console.log('Emergency maneuver - Reveal 1 changed to HEAD');	
                }
                if (entry.isIntersecting && reveal2Going) {
		    reveal2Going = false;	
		    if (!invertedMode) {
		        revealArea2.innerHTML = 'You will pick HEAD';
                        console.log('Emergency maneuver - Reveal 2 changed to HEAD');				    
		    }
		    else {
                        revealArea2.innerHTML = 'You will pick TAIL';			    
                        console.log('Emergency maneuver - Reveal 2 changed to TAIL');
		    }
                }	
                if (entry.isIntersecting && reveal3Going) {
		    reveal3Going = false;
		    revealArea3.innerHTML = 'You will pick HEAD';
                    console.log('Emergency maneuver - Reveal 3 changed to HEAD');				    
                }		    		    
            });
        };
        const observerStats = new IntersectionObserver(scrolledToStats, options);
        observerStats.observe(stats);  

	
	/* functions to change the reveals - called by timers */
        function setTail1() {
            if (reveal1Going && !reveal1Locked) {
                revealArea1.innerHTML = 'You will pick TAIL';
                console.log('Reveal 1 changed to TAIL');
            }
            else {
                console.log('Reveal 1 not changed to TAIL because it is locked');    
            }
        }            
            
        function setTail2() {
            if (reveal2Going && !reveal2Locked) {
		if (!invertedMode) {
                    revealArea2.innerHTML = 'You will pick TAIL';
		}
		else {
	             revealArea2.innerHTML = 'You will pick HEAD';
		}		    
                console.log('Reveal 2 changed to TAIL');
            }
            else {
                console.log('Reveal 2 not changed to TAIL because it is locked');    
            }
        }   
            
        function setTail3() {		
            if (reveal3Going && !reveal3Locked) {
                revealArea3.innerHTML = 'You will pick TAIL';
                console.log('Reveal 3 changed to TAIL');
            }
            else {
                console.log('Reveal 3 not changed to TAIL because it is locked');    
            }
        }           
            
        function deleteFinalStuff() {
            if (!finalStuffLocked) {
                finalStuff.innerHTML = '<div class="interaction-box" style="font-size: 4em;">NO</div></div>';
                console.log('Final stuff deleted and replaced with a "NO"');
            }
            else {
                console.log('Final stuff not deleted because it was locked');    
            }
        }            

///////////////////////////////////////////////////////////
// Taking care of loading screens, password screen, etc. //
///////////////////////////////////////////////////////////
	
// Variable to store the wake lock sentinel
let wakeLock = null;

// Function to request a wake lock
async function requestWakeLock() {
    try {
        wakeLock = await navigator.wakeLock.request('screen');
        console.log('Screen wake lock is active!');
        // You might want to add a small visual indicator to the user
        // that screen lock is disabled.
    } catch (err) {
        // The user has denied the request, or the browser doesn't support Wake Lock
        console.error(`${err.name}, ${err.message}`);
    }
}

// Function to release the wake lock (important for good practice)
function releaseWakeLock() {
    if (wakeLock) {
        wakeLock.release();
        wakeLock = null;
        console.log('Screen wake lock is released!');
    }
}

document.addEventListener('visibilitychange', () => {
    if (wakeLock !== null && document.visibilityState === 'hidden') {
        releaseWakeLock();
    }
});

document.addEventListener('beforeunload', () => {
    releaseWakeLock(); // Try to release before the page unloads
});

	
        function handleGenerateClick() {
            
            const enteredPasswordRaw = passwordInput.value;
            const enteredPasswordLower = enteredPasswordRaw.toLowerCase();

	    let fingerMode = false;
	    let seriousMode = false;

	    // Check if "instructions" was entered
            if (enteredPasswordLower.startsWith('instructions')) {
               passwordScreen.style.display = 'none'; // Hide the password screen
               explanationScreen.style.display = 'flex'; // Show the loading screen (using flex for centering)		
	       window.scrollTo({ top: 0, behavior: 'auto' });
            }
		
            // Check if the base password matches
            if (!enteredPasswordLower.startsWith(BASE_PASSWORD)) {
               errorMessage.textContent = 'Incorrect password. Please try again.';
               passwordInput.value = '';
               passwordInput.focus();
               return; // Exit if base password doesn't match
            }
            console.log('pwd entered');
            // Extract the modifier part of the password
            let modifierString = enteredPasswordLower.substring(BASE_PASSWORD.length);

            // --- Parse for "Serious Mode" (s) ---
            if (modifierString.includes('s')) {
		seriousMode = true;
                funnyStats.style.display="none";                
                modifierString = modifierString.replace('s', ''); // Remove 's' to easily find numbers
            }

            // --- Parse for "Inverted Mode" (i) ---
            if (modifierString.includes('i')) {
		invertedMode = true;
                revealArea2.innerHTML='You will pick TAIL';         
                modifierString = modifierString.replace('i', ''); // Remove 'i' to easily find numbers
            }		

	    // --- Parse for "Finger Mode" (i) ---
            if (modifierString.includes('f')) {
                fingerMode=true;
                modifierString = modifierString.replace('f', ''); // Remove 'f' to easily find numbers
            }			

            // --- Parse for two-digit number (delay) ---
            const delayMatch = modifierString.match(/\d{2}/); // Regex to find exactly two digits
            if (delayMatch) {
                const potentialDelay = parseInt(delayMatch[0], 10);
                // Check if the number is within the desired range (10-60)
                if (potentialDelay >= 10 && potentialDelay <= 60) {
                    delayTime = potentialDelay * 1000; // Convert seconds to milliseconds
                }
            }

            errorMessage.textContent = ''; // Clear any previous error
            passwordScreen.style.display = 'none'; // Hide the password screen
            loadingScreen.style.display = 'flex'; // Show the loading screen (using flex for centering)
	    window.scrollTo({ top: 0, behavior: 'auto' });
            document.body.style.overflow = 'hidden';

            if (!fingerMode) {
		if (seriousMode) {
		    loadingTitle.innerHTML='Generating Prediction';
		    loadingText.innerHTML='Please wait';
		}
		else {
                    loadingTitle.innerHTML='Generating Prophecy';	
		    loadingText.innerHTML='Please wait, our algorithms are analyzing the cosmic data streams';
		}
	        loadingButton.style.visibility='hidden';		    
                // Set a timeout to display the prediction content after a delay
                setTimeout(() => {
                    loadingScreen.style.display = 'none'; // Hide the loading screen
                    predictionContent.style.display = 'block'; // Show the prediction content
	            window.scrollTo({ top: 0, behavior: 'auto' });
                    document.body.style.overflow = '';
                    // Request a wake lock when the prediction page is shown
                    requestWakeLock();
                }, 11*1000); // Use the defined delay
	    }
	    else { // finger mode
		loadingTitle.innerHTML = 'Scanning';	
		loadingSpinner.style.display = 'none';
	    }	
            loadingBarContainer.style.visibility   = 'hidden';
	    loadingBar.style.visibility            = 'hidden';
	    loadingProgressText.style.visibility   = 'hidden';		
            // Request a wake lock when the prediction page is shown
            if ('wakeLock' in navigator) {
                requestWakeLock();
            } else {
                console.warn("Wake Lock API not supported in this browser.");
            }
        }

        // --- Event Listeners ---
        generateButton.addEventListener('click', handleGenerateClick);

        // Allow pressing Enter key in the password field to trigger the button click
        passwordInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                handleGenerateClick();
            }
        });


                


  


	
	////////////////////////////////////
	// Scanning the spectator's brain //
        ////////////////////////////////////





        function loadingUpdateProgressBar() {
            // Set the width of the progress bar fill element
            loadingBar.style.width = `${loadingProgress}%`;
	    loadingProgressText.textContent = `Scan Progress: ${Math.round(loadingProgress)}%`;
	    if (loadingProgress==0)
		loadingText.innerHTML = `Establishing connection...`;
	    if (loadingProgress==8)
		loadingText.innerHTML = `SUCCESS<br><br>Downloading memories...`;	
            if (loadingProgress==16)
		loadingText.innerHTML = `Download complete<br>(${getRandomFloat(80.0, 99.9, 1).toFixed(1)} TBytes)`;
            if (loadingProgress==24)
		loadingText.innerHTML = `Basic personality analysis started...`;		
            if (loadingProgress==32) {
		const FUNNY_ANIMALS = ["Sloth", "Platypus", "Pangolin", "Blobfish", "Tapir",
				       "Capybara", "Mole", "Octopus", "Sea Cucumber", "Manatee",
				       "Wombat", "Armadillo", "Puffin", "Emu", "Hedgehog",
                                       "Tuna", "Otter", "Chinchilla", "Alpaca", "Lemur"];
		loadingText.innerHTML = `Estimated brain volume: ${getRandomInt(1060,1499)} cm<sup>3</sup><br><br>Personality type: <strong>${FUNNY_ANIMALS[Math.floor(Math.random() * FUNNY_ANIMALS.length)]}</strong>`;				
	    }
	    if (loadingProgress==48)
		loadingText.innerHTML = `Analyzing goals and aspirations...`;		
	    if (loadingProgress==56)
		loadingText.innerHTML = `Assessing weaknesses and limitations...`;		
	    if (loadingProgress==64)
		loadingText.innerHTML = `Contacting the deepest layers of the unconscious mind`;
	    if (loadingProgress==72)
		loadingText.innerHTML = `Brainstem-to-Server connection confirmed`;
            if (loadingProgress==80)
		loadingText.innerHTML = `Analyzing final destiny...`;
            if (loadingProgress==88) {
		loadingText.classList.add('blink');
		loadingText.innerHTML = `<strong>Please hold on as your soul is scanned</strong>`;  
	    }
	    if (loadingProgress==100) {
		loadingText.classList.remove('blink');
		loadingScreen.style.display = 'none'; // Hide the loading screen
		nrOfSecondsSpan.textContent = `${getRandomFloat(50.00, 59.99, 2).toFixed(2)}`;
		funnyStats.style.display = 'none';    
                predictionContent.style.display = 'block'; // Show the prediction content
	        window.scrollTo({ top: 0, behavior: 'auto' });
                document.body.style.overflow = '';
                // Request a wake lock when the prediction page is shown
                requestWakeLock();
	    }
	}

        /**
         * Starts the progress bar animation and adds the spinning class to the button.
         * Clears any existing interval and sets up a new one.
         */
        function loadingStartProgress() {
            // If an interval is already running, clear it to prevent multiple timers
            loadingBarContainer.style.visibility   = 'visible';
	    loadingBar.style.visibility            = 'visible';
	    loadingProgressText.style.visibility   = 'visible';	
            if (loadingIntervalId !== null) {
                clearInterval(loadingIntervalId);
            }

            // If progress is already at 100%, reset to 0 to start over on a new press
            if (loadingProgress >= 100) {
                loadingProgress = 0;
            }
            loadingUpdateProgressBar(); // Update immediately to show current/reset progress

            // Add the 'spinning' class to the button to activate the spinner effect
            loadingButton.classList.add('spinning');

            // Set up the interval to increment progress
            loadingIntervalId = setInterval(() => {
                if (loadingProgress < 100) {
                    loadingProgress += loadingProgressIncrement; // Increase progress
                    if (loadingProgress > 100) {
                        loadingProgress = 100; // Cap progress at 100%
                    }
                    loadingUpdateProgressBar(); // Update the display
                } else {
                    // If 100% is reached, stop the interval
                    clearInterval(loadingIntervalId);
                    loadingIntervalId = null; // Reset loadingIntervalId
                    // The progress will stay at 100% until the button is pressed again
                    loadingButton.classList.remove('spinning'); // Stop spinning when complete
                }
            }, loadingIntervalTime);
        }

        /**
         * Stops the progress bar animation and removes the spinning class from the button.
         */
        function loadingStopProgress() {
            if (loadingIntervalId !== null) {
                clearInterval(loadingIntervalId); // Stop the timer
                loadingIntervalId = null; // Reset loadingIntervalId
            }
            // Remove the 'spinning' class from the button to stop the spinner effect
            loadingButton.classList.remove('spinning');
        }

        // --- Event Listeners for Mouse (for desktop users) ---
        // When the mouse button is pressed down on the round button
        loadingButton.addEventListener('mousedown', loadingStartProgress);
        // When the mouse button is released (anywhere after pressing the button)
        loadingButton.addEventListener('mouseup', loadingStopProgress);
        // Important: If the mouse cursor leaves the button while still pressed, stop progress
        loadingButton.addEventListener('mouseleave', loadingStopProgress);

        // --- Event Listeners for Touch (for mobile users) ---
        // When a touch starts on the round button
        loadingButton.addEventListener('touchstart', (event) => {
            // Prevent default touch behaviors like scrolling or zooming, which can interfere
            event.preventDefault();
            loadingStartProgress();
        }, { passive: false }); // Use { passive: false } to allow preventDefault

        // When a touch ends (finger lifted)
        loadingButton.addEventListener('touchend', loadingStopProgress);
        // When a touch is interrupted (e.g., user gets a call, or finger slides off screen)
        loadingButton.addEventListener('touchcancel', loadingStopProgress);

        // Initialize the progress bar state when the page finishes loading
        document.addEventListener('DOMContentLoaded', loadingUpdateProgressBar);
	
});
    </script>
</body>
</html>
