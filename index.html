



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Machine</title>

	
    <style>
	::-webkit-scrollbar {
            width: 0 !important; /* Hides vertical scrollbar by making its width zero */ 
            height: 0 !important; /* Hides horizontal scrollbar by making its height zero */
            display: none; /* Fallback for some specific cases or older versions */
        }

    /* For Firefox */
    html, body {
        scrollbar-width: none; /* Hides the standard scrollbar in Firefox */
    }

/* For Internet Explorer and Edge (older versions) */
    html, body {
        -ms-overflow-style: none; /* Hides scrollbar in IE/Edge */
    }
	    
    body {
        font-family: Arial, sans-serif;
        text-align: center;            
        margin: 0;
        padding: 0;
        background-color: #f0f0f0;
        color: #333;
        font-size: 1em;
        line-height: 1.6;
    }
	    
    .container {
        max-width: 800px;
        margin: 0px auto;
        padding: 20px;
        background-color: #fff;
        font-size: 1.25em;
	text-align: center;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
	    
        #predictionContent {
            display: none; /* Initially hidden */
        }
        h1, h2, h3 {
            text-align: center;
            color: #d76324;
        }
        p {
            margin-bottom: 1em;
        }

	a {
            color: #d76324;
	}	    

        /* Input group for label and input */
        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }

        input[type="password"] {
            width: calc(100% - 20px); /* Account for padding */
            padding: 12px 10px;
            border: 2px solid #ced4da; /* Light grey border, can be adjusted for new palette */
            border-radius: 8px;
            font-size: 1em;
            margin: 20px auto;
            box-sizing: border-box; /* Include padding and border in element's total width and height */
        }

        /* Button styling */
        button {
            background-color: #959595;
            color: white;
            padding: 14px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        button:hover {
            background-color: #7A7A7A; /* Darker grey on hover */
        }

        /* Error message styling */
        .message {
            margin-top: 20px;
            font-weight: bold;
            color: #dc3545; /* Red for error messages */
        }

        /* Styling for the loading screen */
        #loadingScreen {
            display: none; /* Initially hidden */
            min-height: 200px;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 20px;
        }

        /* Styling for the explanation screen */
        #explanationScreen {
            display: none; /* Initially hidden */
            min-height: 200px;
            justify-content: left;
            align-items: left;
	    text-align: left;
            flex-direction: column;
	}

        /* Basic spinner animation on the loading screen*/
        .spinner {
            border: 8px solid rgba(0, 0, 0, 0.1);
            border-top: 8px solid #d76324; /* Spinner color matching heading */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-top: 20px;
            margin-bottom: 20px;            
            display: flex;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .container {
                padding: 25px;
            }
            h1, h2 {
                font-size: 1.8em;
            }
            button {
                padding: 12px 20px;
                font-size: 1em;
            }
            input[type="password"] {
                padding: 10px 8px;
            }
            .spinner {
                width: 40px;
                height: 40px;
                border-width: 6px;
            }
        }

        /* --- Box Styling --- */
        .interaction-box {
            text-align: center;
            margin: 80px 0; /* Vertical spacing between boxes and content */
            padding: 40px 20px;
            background-color: #e9e9e9; /* Grey box */
            border-radius: 8px;
            font-size: 1.5em;
            font-weight: bold;
            color: #555;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none; /* For Safari */
            -moz-user-select: none; /* For Firefox */
            touch-action: pan-y; /* Allow vertical scrolling, prevent horizontal or zoom on touch */
            position: relative;
        }

        /* --- White Gaps --- */
        .white-gap {
            height: 100vh;
            background-color: #fff;
            margin: 0;
            padding: 0;
        }

        /* --- Generic Content / Filler --- */
        .generic-content {
            margin-top: 50px;
            margin-bottom: 50px;
            padding: 20px;
            background-color: #f8f8f8;
            font-size: 1em;
            border-radius: 5px;
            text-align: center;
        }

        .scan-finger-button {
            width: 100px; /* Fixed width for a perfect circle */
            height: 100px; /* Fixed height for a perfect circle */
            border-radius: 50%; /* Makes it round */
            padding: 0; /* Remove padding as there's no text */
            display: flex; /* Use flex to center any potential icon/inner elements */
            justify-content: center;
            align-items: center;
            font-size: 0; /* Hide any default text if present */
            background-color: #e0e0e0; /* Grey background */
            border: 5px solid #d76324; /* Orange border */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); /* Soft shadow */
        }

        .scan-finger-button:hover {
            background-color: #d0d0d0; /* Slightly darker grey on hover */
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .scan-finger-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Scan progress text */
        #scanProgressText {
            margin-top: 15px;
            font-weight: bold;
            color: #d76324;
        }

        /* Progress bar styling */
        .progress-bar-container {
            width: 80%;
            background-color: #e0e0e0;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 20px;
            height: 20px;
        }

        .progress-bar-fill {
            height: 100%;
            width: 0%; /* Initial width */
            background-color: #d76324;
            border-radius: 5px;
            transition: width 0.1s linear; /* Smooth transition for progress */
        }
	    
        /* Warning message styling */
        #warningMessage {
            color: #dc3545; /* Red color for warning */
            font-weight: bold;
            font-size: 1.2em;
            margin-top: 20px;
            visibility: none; /* Hidden by default */
        }

        /* Blinking class for messages */
        .blink {
            animation: blink 0.8s infinite alternate;
        }

        @keyframes blink {
            0% { opacity: 1; }
            100% { opacity: 0.3; }
        }



        /* Responsive adjustments */
        @media (max-width: 600px) {
            .container {
                padding: 25px;
                font-size: 1.1em; /* Slightly smaller base for container on mobile */
            }
            h2 {
                font-size: 1.6em; /* Adjust heading size */
            }
            p {
                font-size: 1em; /* Adjust paragraph size */
            }
            button { /* General button styling */
                padding: 12px 20px;
                font-size: 1.2em;
            }
            .scan-finger-button { /* Specific scan button styling on mobile */
                width: 80px;
                height: 80px;
            }
        }
    </style>














	    
    </style>
</head>
<body>

    <div id="passwordScreen" class="container">
        <h1>Welcome to<br>The Machine</h1>
        <div class="input-group">
            <label for="password">Predicting Your Future Since 1999</label>
            <input type="password" id="password" placeholder="" autocomplete="current-password">
        </div>
        <button id="generatePredictionButton">Generate Prediction</button>
        <p class="message" id="errorMessage"></p>
        <hr style="border: none;">
        <hr style="border: none;">	
	<p>Created and maintained by <a style="color: #000000#;" href="https://jmc-magic.com">J.M. Chabloz</a>, with the help of the greatest consortium of magicians and visionaries that ever came together:</p>	    
	<div id="contributors">
	</div>
        <hr style="border: none;">
        <hr style="border: none;">		    
        <a href="https://jmc-magic.com">jmc-magic.com</a>
        <hr style="border: none;">
        <hr style="border: none;">	    
        <p><a style="color: #000000;" href="https://jmc-magic.com">Click here</a> if you are a magician and want to know more about how the machine predicts the future.</p>	    
        <hr style="border: none;">
        <hr style="border: none;">		    	    		    
    </div>

    <div id="loadingScreen" class="container">
        <h1 id=loadingTitle>Scanning</h1>
        <p id="loadingText">Press and hold the button to initiate scan.</p>
        <div id="loadingSpinner" class="spinner"></div>
	<div id="loadingBarContainer" class="progress-bar-container">    
            <div id="loadingBar" class="progress-bar-fill"></div>
        </div>
	<p id="loadingProgress">Scan Progress: 0%</p>
        <button id="loadingButton" class="scan-finger-button"></button>
        <p id="loadingWarning">DO NOT LIFT YOUR FINGER!<br>Hold it in place until your soul is completely scanned!</p>	    
        <div class="white-gap"></div> 			    
    </div>

    <div id="predictionContent" class="container">    
        <h1>Prediction Completed</h1>
        <hr style="border: none;">
        <hr style="border: none;">        
	<div id="stats">
            <p>Prediction generated in <span id="nrOfSeconds"></span> s.</p>
            <hr style="border: none;">
            <hr style="border: none;">
            <div id="funnyStats">
                <p><span id="crystalBalls"></span> digital crystal balls analyzed.</p>
                <p><span id="teaLeaves"></span> algorithmic tea leaves interpreted.</p>
                <p><span id="tarotCards"></span> decks of virtual tarot cards shuffled.</p>
                <p><span id="sheepEntrails"></span> electronic sheep's entrails recreated and observed.</p>
            </div>
	</div>
        <div class="white-gap"></div>
	    <div id="stopSign" style="font-size: 4em">
            STOP
        </div>
        <p>Prediction starts below.</p>
        <div class="white-gap"></div>        
	<div class="interaction-box" id="boxr1">
            You will pick HEAD
        </div>
        <div class="white-gap"></div>        
	<div class="interaction-box" id="boxr2">
            You will pick HEAD
        </div>
        <div class="white-gap"></div>
	<div class="interaction-box" id="boxr3">
            You will pick HEAD
        </div>
        <div class="white-gap"></div>
	<div class="interaction-box" id="boxr4">
            You will pick TAIL
        </div>
        <div class="white-gap"></div>        
        <div id = finalStuff>
	    <div class="interaction-box">
                ...and you will pick HEAD...
            </div>
            <div class="white-gap"></div>             
	        <div class="interaction-box">
                ...and then TAIL again...
            </div>            
            <div class="white-gap"></div>             
	    <div class="interaction-box">
                You will change your mind several times in your head...
            </div>                    
            <div class="white-gap"></div>             
	    <div class="interaction-box">
                ...but in the end...
            </div>               
            <div class="white-gap"></div>             
	    <div class="interaction-box">
                ...you will choose...
            </div>
            <div class="white-gap"></div>
            <div class="interaction-box" style="font-size: 4em;">
                HEAD
            </div>
        </div>

        <div class="generic-content">
            <p>Free will is an overrated concept.</p>
            <hr style="border: none;">
            <hr style="border: none;">
            <p><i>Thank you.</i></p>
            <hr style="border: none;">
            <hr style="border: none;">		
            <a href="https://jmc-magic.com">jmc-magic.com</a>
        </div>
    </div>

    <div id="explanationScreen" class="container">
        <h1>Instructions</h1>
	<p>Welcome to the secret area of this website. Here you will find the instructions to perform this trick for your audience.</p>
	<p>If you reached this page by acing the "magician's exam", I have good news: you don't need to take it anymore, you can reach this page by simply typing <strong><em>instructions</em></strong> in the password field of the main page, and then pressing cliking on the <em>generate prediction</em>em> button.</p>
	<p>If you are not a magician, and managed to sneak in here somehow, welcome anyway :) If you really want to know how The Machine works, read further and you will find out. Might this look behind the scenes inspire you, and maybe become the start of your magical journey - every magician in the world must start somewhere, after all.</p>
	<p>I hope you will not be too disappointed to know, however, that this machine does not predict the future: this is just a magic trick.</p>
	<h3>In a nutshell, what is this trick?</h3>
	<p>This trick is a strong piece of mentalism with un unconventional hook. Because of its very nature, it would be a difficult trick to market, and I am therefore offering it as a free trick on the web, open for any magician to use.</p>
	<p>From the point of view of the spectator, what happens is that the magician gives them a web address to connect to with their mobile phone. Once they reach the page, the magician gives them a password, they type it in, they press a button and a prediction is generated. The magician explains that this prediction contains four separate HEAD / TAIL predictions for four mental coin tosses (free HEAD / TAIL choices). For three times in  row, the spectator announce their choice - HEAD or TAIL, the magician asks them to scroll down in the prediction page, and, each and every time, the prediction on the page matches their free choice.</p>
	<p>The fourth time, the magician announces them that, to remove all doubts about cheating, this time they are not even going to announce their choice out loud, it will just exist in their head. They make their choice, they scroll down the page, and, incredibly, the prediction matches again.</p>
	<p>Features:</p>
	<ul>
	<li>No sleight of hand</li>
	<li>No fancy technology, works in principle on any modern mobile</li>
	<li>The method is well protected and cannot be discovered by generating new predictions or inspecting the page source.</li>
	<li>perfect EDC: you don't need to supply anything, since you will use the spectator's mobile</li>
	<li>could even be performed remotely over a video-link, since you never come near the spectator's phone</li>
	<li>Totally free fo anyone to perform!</li>
	</ul>
	<h3>In a nutshell, what is the method?</h3>
	<p>Timers! For the first three reveals, every time that the spectator announces their pick, you either let them scroll down immediateley to the next reveal, or you talk for a while and delay the scrolling. After a 20 seconds delay, the text on the reveal changes.</p>
	<p>The last reveal, in which they do not even announce their choice out loud, is based on the combination of a timer, clever wording and multiple outs. When the spectator scrolls down to the fourth reveal, it might or might not match their choice. If it matches, a clever psychological trick will make the spectator stop scrolling until all what comes after the reveal is deleted by a timer expiration. If it does not match, you ask them to just continue scrolling, and they will discover that, actually, what they thought was a wrong reveal was just a part of a longer reveal, that ultimately matches their choice.</p>
        <h3>Question: What is the password to activate the machine?</h3>	    
	<p>The password is <strong>cigamcmj</strong>. It is case-insensitive, so it doesn't matter whether or not some or all letters are written in capitals. The password is "jmc magic" written backwards, so you can remember it easily. You should not tell this to your audience, though. Just tell them the letters, one by one, and let them enter them in the password field.</p>
<p>Basically, the reason there is a password system on the page is to prevent the spectator from reloading the page and generating their predictions once your performance is finished. And that is also the reason why the password is complex: if the password was a simple word, like "future", it would be easy for the spectator to remember it. After your performance, they would be able to reload the page, generate a new prediction, and gain a significant, even if uncomplete, insight on how this trick works.</p>
	<p>By asking the spectator to add letters and numbers at the end of the password, you can add a few modifiers that change some parameters of the trick to better suit different performers. This is discussed in section XXXXXXXX</p>
	<h3>Question: can anyone use this trick for free?</h3>
	<p>Yes. Next time you have a spectator in front of you, ask them simply to connect to <a href="www.the-machine.org">www.the-machine.org</a>, give them the password and ask them to generate a prediction. Try the trick out, see how it goes. If you like it, great! If you are an amateur magician, a young magician just starting out, a struggling magician, don't worry, you can use this for free, forever. I only ask you to please prepare well to perform the trick, and to not gratituously expose it. Spread the word to other magicians, if you can, and do not hesitate to explain how the trick works to other magicians, but keep it secret from your spectators, so that magic can continue to be magical for them.</p>
<p>If you are a professional magician, who earns money through magic and is not in financial trouble, and if you tried this and you liked it, I would appreciate a donation. You can find the donation link at the bottom of this page. I am a creator of magic, and getting some support would help me to continue creating. Also, you might have noticed that the main page states that the machine was created and is maintained by J.M. Chabloz (me), with the help of "the greatest consortium of magicians and visionaries that ever came together". And then there is a list of names. As I start this website, in the summer of 2025, I am initializing the list with ten fake magicians' names, but all donators, unless they opt out, can have their name added to the list. If you donate, you will be able to point out your name in the list, and tell the spectator that you were also part of the magicians' consortium that created the page. It's a cool hook, I think.</p>
<p>About the amount of the donation, you be the judge. You know what is the price of a magic trick. You know how this is worth for you. You be the judge.</p>
        <h3>How is the trick performed?</h3>
	<p>You are of course free to come out with your own presentation for the trick, but I suggest to start by talking to your audience about "The Machine", an experimental magical machine to predict the future, created by a consortium of magicians. You give them the website and they navigate to it with their mobile phones. You could even print yourself out a sticker with a QR code, if you prefere. If your name is in the "contributors' list", you can point it out to the spectator. If not, do not hesitate to tell the spectator that you also recently did some consultancy on the project, and that, as a result, you were given the password to generate predictions. You can mention that you recently met the creator of the page at a magic convention and that you agreed to also contribute your knowledge to improve the machine - that's why you have the password. This way, your name's absence from the list will not raise any eyebrow.</p>
<p>Give the spectator the time to explore the first page, if they are in the mood for it, don't be in a hurry to continue with the trick.</p>
<p>Explain that predicting the future is extremely hard, but that, after years of improvements, the machine is now able to predict up to four "mental coin tosses" (mental HEAD / TAIL choices). If you and the spectator are in the right mood, you can fill in with funny details: "in the early 2000s, before my time, they could predict one coin toss 80% of the time, and that was all, but then the machine kept improving... If I remember well, 2012 was the first time they could consistently get two mental coin tosses right, which was a big thing in the magic community... Now we are up to four."<p>
<p>Tell the spectator that, after the prediction is generated, they will be asked four times to choose "HEAD or TAIL" in their head, and that the machine's prediction will always match their choice.</p>
<p>Once it is time to move on, give the password to the spectator (append modifiers at the password end if you so desire to personalize the trick). Do not say "the password is jmcmagic written backwards", just give them the letters one by one. You do not want them to remember the password afterwards."</p>
<p>Hold on for 11 seconds, while the machine "does its work". You can talk about how "nobody really understands how the machine really works - so many talented magicians have come together to build it, and everyone has only knowledge about their own part since everyone is so secretive. This creates hype, and hopefully makes the spectator curious and invested in what's going on.</p>
<p>Once the prediction page is loaded up, take your time before continuing.</p>
<p>It is very important, at this point, to explain to the spectator that the page contains the predictions, and they will have to scroll down to see them. Tell them very clearly to scroll down slowly, because you want to reveal the predictions one by one, and you don't want them to see, by mistake, the predictions that come after.</p>
<p>If the spectator scrolls down the page without being careful, the trick will fail - you do not want that to happen. There must be hype and tension, the spectator cannot be too relaxed or they might just casually scroll down after making their choice.</p>
<p>To mitigate this, if you have a table, ask the spectator to lay their mobile flat on the surface, so "we can all see what's going on". This way, scrolling requires a more unnatural and unfamiliar motion compared to when the mobile is in their hand, and they will be more unlikely to just casually do it. Also, haviung the mobile lying flat, with everyone's eyes on it, will make the reveal seem more "serious", pushing the spectator to scroll slowlier and more carefully.</p> 
<p>The other mitigation you will use is asking the spectator to look you in the eyes when making their mental coin tosses. This way, they will necessarily have to lift their eyes from their mobile, and, again, this will prevent them to casually scrolling down after making their choice.</p>
<p>Still, if you sense that the spectator is not trustable and might casually scroll down before you tell them to, then it is probably best that you get the mobile phone in your own hands and do the scrolling yourself. It's a little less strong, but it is much safer.</p>
<p>If you choose to go down this route, the spectator will probably not object to you getting their mobile out of their hands, since at this point they do not know anything about how the prediction page is structured, and they might think that reading the predictions is a complex operation, for which you are needed. They still don't know that it's just a matter of scrolling down, at this point.</p>
<p>One other thing that you can optionally do, at this point, is to ask the spectator to turn off the wi-fi and to put their mobile in airplane mode to isolate it from the world and prevent anyone to enter their mobile to change the prediction" However, I do not normally do this, because I think that it interferes with the flow of the magic and it might introduce suspicion - until that point, the spectator might not even had the thought of the text on page might change.</p>
<p>There is some funny text under the page header of the prediction page - text about crystal balls, tea leaves, tarot cards and sheeps' entrails. If you don't like it, consider activating "serious mode" by appending the letter "s" to the passsword you give your spectator. You can point out to the spectator that these are all code words, to indicate different parts of the machine's prediction algorithm - the magicians in the consortium are very secretive and have a twisted sense of humor, apparently!</p>
<p>Once you are done with talking and exploring the top of the page, it's time to start scrolling. Ask your spectator to scroll down to the STOP sign.</p>
<p>As soon as the STOP sign appears on the screen, the first timer starts. Now, if they scroll down to the first reveal within 20 seconds, the reveal will say "You will pick HEAD". If it takes them longer than that, the reveal will say "You will pick TAIL".</p>
<p>Note that, as soon as the first reveal appears on the screen even for a fraction of a second, it will be locked forever. All reveals on the page work in this way, which ensures that reveals do not ever change once they are seen by the spectator. This guarantees that, from the point of view of the spectator, the page will always look like a static page containing just formatted text and no weird, changing elements.<p>	    
<p>Ask the spectator to look you in the eyes as they make their choice: head or tail. They will say "HEAD" or "TAIL".</p>
<p>If they say "HEAD", just calmly ask them to scroll down to the first reveal. This might be a good time to reiterate to please scroll slow, so they don't accidentally show the second reveal.</p>
<p>If they say "TAIL", then it is time to talk in order to delay their scroll. My suggestion, for every time you have to babble, is to talk about the fact that, based on statistics that you saw, the spectator's choice is the less common option. On the first reveal, tell them that you just saw statistics from the machine, and saw that actually TAIL is chosen around 43% of the time, while HEAD is chosen 57% of the time. If you want to continue babble, tell the spectator that this is maybe counter-intuitive. Most would think that, when given a binary choice, most people would go for the second option in order to try tricking the machine, but no, this is actually not the case. Or you can mention that there are other studies coming to similar conclusions. Whatever. Just babble for a while, then pause, create hype - you are not on a timer and can take your time - and finally ask the spectator to scroll down slowly to the first reveal.</p>
<p>Once the first reveal appears, the second reveal timer starts automatically.</p>
<p>Once again, ask the spectator to look you in the eyes and make their choice.</p>
<p>Again, if they pick HEAD, tell them to scroll down. You should not look too much in a hurry. You have 20 seconds, there is no need to look suspicious.</p>	    
<p>If they choose TAIL, you have to babble. They either chose twice TAIL, or they chose HEAD and then switched to TAIL. My suggestion is that you discuss how the action they took (same choice twice, or choice switch), is the most uncommon based on the statistics. If, for example, they choose two tails in a row, tell them that based on the statistics, 58% of the people always change their choice when making two mental coin tosses in a row. Just like for reveal 1, talk about how other studies are confirming this, etc. After you babble for 20 seconds, pause, create some hype and then ask your spectator to scroll down.</p>	    	    
<p>Once the second reveal appears on the screen, the third timer starts automatically.</p>	    
<p>Repeat the procedure for the third time: ask them to look you in the eyes and make their choice. Based on the choice, either ask them to scroll directly down, or babble for a while about statistics, or - if you so prefere - about how hard it is to predict a persons' choice and about how amazing the machine actually is.</p>	    
<p>A potential problem that might occur, once in a while, is that a spectator chooses HEAD, but you get interrupted by something during the performance - like a waiter coming over in a restaurant - and too much time passes. There is an emergency procedure to recover from this, which you can read about in section XXXXXXX</p>
<p>Also, if you want your trick to be as hard to backtrack as possible, you can decide to perform your trick in "inverted mode", by adding "i" at the end of the password you provide to the spectator. In this case, the second reveal is inverted: it will be TAIL if you scroll immediately, and HEAD if you wait. The idea behind this is that the spectator will not be able to identify the pattern "waiting equals TAIL" because it is not consistent in this mode. You can read more about  in section XXXXXXX</p>
<p>Once you reach the third reveal, there is no timer going on. You can therefore take your time to talk to the spectator about the fantastic feat of foresight that the machine just pulled off. Then, talk about the final step. To prove beyond any reasonable doubt that the machine really works, this time the spectator will not even tell out loud what their choice is - they will pick a value and the value will just stay in their mind. It is important that you ask them to do their last choice in a specific way: you want them to "pick a value in their head", then "switch and pick the other one" and then "switch again and pick the other one, and then the other one, and then the other one". Tell them you want them to continue switching for a while, and then make their mind and stop switching. Explain them that this procedure will ensure that the final choice is "as random as possible". And tell them that you don't want them to say anything out loud about their choice: the choice must be just in their head.</p>
<p>Let them do their choice based on this procedure. When they are done, you can create some more hype by pointing out how unbelievable it would be for the machine to pull this last prediction off, and then tell them to scroll down. By this point, they should have understood that they schould scroll slowly. The fourth reveal always says "You will pick TAIL". Once it comes into view, a fourth and final 20 seconds timer is started. At this point, one of two things will happen.</p>
<p>The first possibility is that, when the fourth reveal comes into view, the spectator will say "No, that's wrong" because they had chosen HEAD in their head. Without losing one beat, just tell the spectator "Wrong? Scroll down, I think the prediction is not finished.". And as the spectator scrolls down, several predictions will come into focus, one after the other. They will say: "...and you will pick HEAD..." "...and then TAIL again..." "You will change your mind several times in your head..." "...But in the end..." "......" "HEAD". And then the page will end. This whole series of reveals will make sense if you have used the correct procedure when asking the spectator to make their final choice. The initial "wrong" reveal will be considered by the spectator to just be "the machine pulling a little joke on them, by pretending it got the prediction wrong when it actually got it right". At this point, the full page content will be absolutely fixed and never change again. Scpectator is free o scroll up and down the page as they please, and will not see anything suspicious. The spectator can reload the page, but they will presented again with the initial password page and, unless they remember the password, they will not be able to regenerate a prediction and investigate the method.</p>
<p>If the spectator had chosen TAIL in their head and the reveal matches, they will be amazed and freak out. Tell them to stop there and don't go further with their scroll, "because there is a final prediction at the bottom of the page". Now take your time to talk about what just happened: the machine just pulled off four guesses in a row, and the last one was even more amazing because the chosen value existed only in the spectator's head! Be sure to talk for more than 20 seconds - this should be easy to pull off, given the miracle that the spectator just witnessed. When you are sure that 20 seconds are gone, tell the spectator "Ok, look, there is one last reveal on the bottom of this page, it's one single word. Do you have any idea what that word is?" Hopefully they will answer "no". Tell them to scroll down, and surely enough, the word at the bottom of the page says "no". The trick then concludes on this joke. The reason why the joke is important, is that you need an excuse for them not to scroll down immediately when the fourth reveal comes into view. If the last joke was not there, it would be extremely suspicious for you to ask them not to scroll any further when they reach the fourth reveal, but the suspicion is removed by the presence of the joke, which gives you a reason to stop scrolling earlier. If they do not answer "no" to your last question, answering perhaps "I don't know", or something similar, no worries. Do not push them further to say "no", just tell them to scroll down and laugh with them, as you tell them that, obviously, the machine is still not perfect, and how they are the first person who didn't answer "No" to that question, managing to fool the machine at the last second. This, hopefully, will end the trick on a positive and good note.<p>
<p></p>	    
<h3>Question: can't the spectator just look at the page code with their browser and understand the secret?</h3>	    
<p>No, the page is obfuscated. If you try to inspect the source code of the page, you will just see a nonsensical mess. Here is a short extract, so you can understand what we are talking about.</p>
<p>&lt"he3;-ts&ltoonttpt~1jd9q~#tjic&lthesfpjf&ltfxopz/qg1b.3s2y|fej&ltbdgj2x1yg&lt!squmospqpypfdef&ltp3;"</p>
<p>The page goes on and on like this for thousands of characters. Code obfuscation is a procedure that takes a human-readable code and transforms it into a code that does exactly the same thing, but is very hard to read. This means that the spectator cannot inspect the source code to understand the password, cannot inspect the source code to read the instructions you are reading now, cannot inspect the source code and see how the page works. Even for an determined and expert coder, armed with the right tools, deobfuscating this page would be a complex and time-consuming opeation. Not impossible, but hard enough to make this be a non-concern.</p>
<p>Incidentally, the fact that the page is obfuscated is not suspicious in itself, since obfuscation is also a common technique to protect a webpage from unwanted modifications: without obfuscation, it would be simple for anyone to edit the source code of the page to show them as authors, and copy the page to their personal website. This is much harder to do with an obfuscated page.</p>	    	    
<h3>Question: will this work on any mobile phone?</h3>	    
<p>The page does not use any fancy technology, just standard webpage scripting (javascript) that should work on any browser from any reasonably modern mobile operating system.</p>
<h3>Question: what is the emergency manouver?</h3>
<p> The emergency manouver is your insurance card. This trick is based on a timer. The first three reveals will show "You will pick HEAD" if they appear on screen before their timer runs out, or "You will pick TAIL" if they appear on screen after their timer has run out. The text following the final reveal also follows this principle. You might, once upon a time, encounter an unpleasant situation in which the timer has run out, and you know that, as soon as the spectator scrolls down, the wrong reveal will be shown. For example, maybe on the first reveal, after you asked the spectator to make their choice, they insisted to make it by using the old coin that they inherited from their grandfather, and which they always have in their wallet. It took them two full minutes to find it in their wallet, and by that time, you knew that the reveal was stuck on "You will pick TAIL". You prayed as hard as you could that the coin toss would stop on TAIL but, of course, this did not happen and you got HEAD.</p>
<p>This sounds like a hopeless situation, but, luckily, the emergency manouver can save you. At any time you have at most one timer-sensitive reveal whose timer has started but that hasn't been shown yet. You can reset the reveal to its bfore-the-timer value by scrolling back up to the top of the page. So, if you encounter this situation, tell the spectator: "look, I will show you something cool, scroll back up to the top of the page". The spectator scrolls up, and then you will point out any number that appears on screen. Maybe the number of crystal balls, or the number of tea leaves. If you are in serious mode, point out the number of seconds it took to generate the prediction. Explain to the spectator that, although there are many parts of the machine that you don't understand, you know that that number, when it is even, or odd, always shows that, for example, the first reveal is "HEAD". Now let the spectator scroll down to the first reveal, and, sure enough, it will say "You will pick HEAD".</p>
<h3>Question: what are the modifiers?</h3>								    
<p>Magicians are all different, and to accomodate different preferences, a few personalization opportunities have been introduced in this trick. These personalization opportunities, or "modifiers", are accessed by adding characters and numbers at the end of the password field. Three different modifiers are allowed, and can be combined. When combining modifiers, just append them in any order you want at the end of the password. Letters are case-insensitive and can be written in capital or small letters. Of course, do not mention to your spectator that these are modifers, treat the modifer letters as if they were a regular part of the password.</p>
<p>Appending an "s" at the end of the password will cause the machine to operate in "serious mode". The loading screen will report "Generating Prediction" instead of "Generating Prophecy" and the sentence "our algorithms are consulting the cosmic data streams" will be omitted. Once the prediction is generated, the "funny statistics" text about crystal balls, tea leaves, tarot cards and sheep's entrails will also be omitted. It's a mode designed for people with a more serious performance style, which could be put off by the comedy.</p>
<p>Appending an "i" at the end of the password will cause the machine to operate in "inverted mode". Although I think this is just a minor concern, it might be possible for some spectator to notice that every time the magician talks before the scroll, the reveal says "TAIL". Note however that this is not the case for the fourth reveal, just for the first three. But, anyway, to be as untrackable as possible, in inverted mode the second reveal is inverted: it will say TAIL if you scroll immediately, and HEAD if you wait.</p>	
<p>Appending a two digit number between 10 and 99 at the end of the password will override the default 20 seconds timer with the value that has been input, to suit different magicians' preferences. If, for example, the number 35 is appended at the end of the password, then all timers will run for 35 seconds instead of 20.</p>
<h3>Question: What if the trick fails?</h3>								    
<p>The webpage is designed in such a way that it should never catasrophically fail by exposing the trick - no reveal will ever change in front of the spectator's eyes. The worst thing that can happen is a wrong prediction.</p>
<p>If this happens, do not hesitate to put the blame on me and/or the other members of the consortium! "Hush!", say, "they really need to improve this machine!" Switch to some other trick, and show how your methods actually work better than the machine.</p>
<p>In other words, the fact that the author trick is clearly stated on the first page can be an advantage in case of failure: do not hesitate to blame him (me) for failures :)</p>
<h3>I would like to run the trick in my language, can I?</h3>
<p>Help me with the translation and I am willing to do it. No promises though, because promises stress me.</p>
<h3>I have in mind a certain feature that I would like to add to this trick</h3>
<p>Let's talk about it. Contact me at chablozjm@gmail.com and let me know what is your idea.</p>
<h3>I found a bug!</h3>
<p>Please contact me at chablozjm@gmail.com</p>
<h3>How can I support you?</h3>
<p>You can donate at XXXXXXXX. Don't feel like you have to, though, if you are an amateur magician, a young magician just starting out, or anyone with any financial trouble. However, if you are a working magician, making money through magic, who likes this trick and thinks you will use it, I would appreciate a donation, which will help me creating more magic. Choose by yourself how much this is worth to you. You will also get your name in the consoritum of magicians on the first page, and will be able to point it out to your spectators! Just tell me which name I should use when doing the donation.</p>
<p>Even if you cannot donate, spreading the word about this page and about the magician who created it and following my social medias are also good ways to show your support!</p>


        <hr style="border: none;">
        <hr style="border: none;">		    	    		    
    </div>

	
    <script>

document.addEventListener('DOMContentLoaded', function() {
	    
        // --- Configuration ---
        const BASE_PASSWORD = 'cigamcmj';        
        let delayTime = 20 * 1000;	    

        // --- Get DOM Elements ---
        const passwordScreen = document.getElementById('passwordScreen');
	const loadingScreen = document.getElementById('loadingScreen');
        const explanationScreen = document.getElementById('explanationScreen');	
        const predictionContent = document.getElementById('predictionContent');
        const passwordInput = document.getElementById('password');
        const generateButton = document.getElementById('generatePredictionButton');
        const errorMessage = document.getElementById('errorMessage');        
        
        /* serious mode*/
        const generatingProphecy = document.getElementById('generatingProphecy');
        const cosmicDataStreams = document.getElementById('cosmicDataStreams');
        const funnyStats = document.getElementById('funnyStats');            
        const crystalBallsSpan = document.getElementById('crystalBalls');
        const teaLeavesSpan = document.getElementById('teaLeaves');
        const tarotCardsSpan = document.getElementById('tarotCards');
        const sheepEntrailsSpan = document.getElementById('sheepEntrails');  
        const nrOfSecondsSpan = document.getElementById('nrOfSeconds');

        /* inverted mode */
	let invertedMode = false;
	    
        /* reveal areas */
        const stopSign    = document.getElementById('stopSign');
        const revealArea1 = document.getElementById('boxr1');
        const revealArea2 = document.getElementById('boxr2');
        const revealArea3 = document.getElementById('boxr3');
        const revealArea4 = document.getElementById('boxr4');
        const finalStuff  = document.getElementById('finalStuff');                       
            
        /* lock reveals */
        let stopSignReached = false;
        let reveal1Locked = false;
        let reveal2Locked = false;
        let reveal3Locked = false;
        let reveal4Reached = false;
        let finalStuffLocked = false;

        /* emergency meneuver */	
	let reveal1Going = false;
	let reveal2Going = false;
	let reveal3Going = false;

	/* loading screen */
        const loadingTitle        = document.getElementById('loadingTitle');	
	const loadingText         = document.getElementById('loadingText');	
	const loadingSpinner      = document.getElementById('loadingSpinner');
	const loadingBarContainer = document.getElementById('loadingBarContainer');	
	const loadingBar          = document.getElementById('loadingBar');	
	const loadingProgress     = document.getElementById('loadingProgress');
	const loadingButton       = document.getElementById('loadingButton');	
	const loadingWarning      = document.getElementById('loadingWarning');
	let   scanGoing           = false;
	let   scanStarted         = false;

        /* Add the contributors list */
        async function loadExternalHTML(url, targetElement) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const htmlText = await response.text();
                targetElement.innerHTML = htmlText;
                console.log(`Successfully loaded ${url}`);
            } catch (error) {
                console.error('Error loading external HTML:', error);
                targetElement.innerHTML = '<p style="color: red;">Failed to load content.</p>';
            }
        }	
	const contributors  = document.getElementById('contributors'); 
        loadExternalHTML('contributors.html', contributors);
	    
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        function getRandomFloat(min, max, decimals) {
            const str = (Math.random() * (max - min) + min).toFixed(decimals);
            return parseFloat(str);
        }
	    
        crystalBallsSpan.textContent = getRandomInt(25, 59);
        teaLeavesSpan.textContent = getRandomInt(400, 799);
        tarotCardsSpan.textContent = getRandomInt(30000, 49999).toLocaleString('en-UK');
        sheepEntrailsSpan.textContent = getRandomInt(3, 9);
        nrOfSecondsSpan.textContent = getRandomFloat(10.00, 10.99, 2).toLocaleString('en-US', {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
            
        /* observer, to determine when stuff becomes visible */
        const options = {
            root: null, // The viewport is the root
            rootMargin: '0px', // No margin around the root
            threshold: 0.01 // Trigger when even 1% of the target is visible
        };

	/* checking when the stop sign becomes visible*/
        const lockRevealStop = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !stopSignReached) {
		    reveal1Going = true;
                    setTimeout(setTail1, delayTime);                             
                    stopSignReached = true;
                    console.log('The stop sign became visible');
                }
            });
        };
        const observerStop = new IntersectionObserver(lockRevealStop, options);
        // Start observing the target div
        observerStop.observe(stopSign);   

        /* checking when reveal 1 becomes visible*/	    
        const lockReveal1 = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !reveal1Locked) {
		    reveal2Going = true;
                    setTimeout(setTail2, delayTime);                             
                    reveal1Locked = true;
                    reveal1Going = false;			
                    console.log('Reveal 1 is locked because Reveal 1 became visible');
                }
            });
        };
        const observer1 = new IntersectionObserver(lockReveal1, options);
        observer1.observe(revealArea1);            
            
        /* checking when reveal 2 becomes visible*/
        const lockReveal2 = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !reveal2Locked) {
		    reveal3Going = true;
                    setTimeout(setTail3, delayTime); 
                    reveal2Locked = true;
                    reveal2Going = false;			
                    console.log('Reveal 2 is locked because Reveal 2 became visible');
                }
            });
        };
        const observer2 = new IntersectionObserver(lockReveal2, options);
        observer2.observe(revealArea2); 
            
        /* checking when reveal 3 becomes visible*/
        const lockReveal3 = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !reveal3Locked) {
                    reveal3Locked = true;
		    reveal3Going = false;
                    console.log('Reveal 3 is locked because Reveal 3 became visible');
                }
            });
        };
        const observer3 = new IntersectionObserver(lockReveal3, options);
        observer3.observe(revealArea3);             

        /* checking when reveal 4 becomes visible*/
        const reachedReveal4 = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !reveal4Reached) {
                    reveal4Reached = true;
                    setTimeout(deleteFinalStuff, delayTime);                         
                    console.log('Reveal 4 became visible');
                }
            });
        };
        const observer4 = new IntersectionObserver(reachedReveal4, options);
        observer4.observe(revealArea4);             
            
        /* checking when final stuff becomes visible */
        const reachedFinalStuff = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !finalStuffLocked) {
                    finalStuffLocked = true;                         
                    console.log('Final Stuff is now locked because it became visible');
                }
            });
        };
        const observerFinal = new IntersectionObserver(reachedFinalStuff, options);
        observerFinal.observe(finalStuff);  

        /* checking when the stats becomes visible */
	/* to enable the emergency maneuver */
        const scrolledToStats = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && reveal1Going) {
		    reveal1Going = false;
		    revealArea1.innerHTML = 'You will pick HEAD';
                    console.log('Emergency maneuver - Reveal 1 changed to HEAD');	
                }
                if (entry.isIntersecting && reveal2Going) {
		    reveal2Going = false;	
		    if (!invertedMode) {
		        revealArea2.innerHTML = 'You will pick HEAD';
                        console.log('Emergency maneuver - Reveal 2 changed to HEAD');				    
		    }
		    else {
                        revealArea2.innerHTML = 'You will pick TAIL';			    
                        console.log('Emergency maneuver - Reveal 2 changed to TAIL');
		    }
                }	
                if (entry.isIntersecting && reveal3Going) {
		    reveal3Going = false;
		    revealArea3.innerHTML = 'You will pick HEAD';
                    console.log('Emergency maneuver - Reveal 3 changed to HEAD');				    
                }		    		    
            });
        };
        const observerStats = new IntersectionObserver(scrolledToStats, options);
        observerStats.observe(stats);  

	
	/* functions to change the reveals - called by timers */
        function setTail1() {
            if (reveal1Going && !reveal1Locked) {
                revealArea1.innerHTML = 'You will pick TAIL';
                console.log('Reveal 1 changed to TAIL');
            }
            else {
                console.log('Reveal 1 not changed to TAIL because it is locked');    
            }
        }            
            
        function setTail2() {
            if (reveal2Going && !reveal2Locked) {
		if (!invertedMode) {
                    revealArea2.innerHTML = 'You will pick TAIL';
		}
		else {
	             revealArea2.innerHTML = 'You will pick HEAD';
		}		    
                console.log('Reveal 2 changed to TAIL');
            }
            else {
                console.log('Reveal 2 not changed to TAIL because it is locked');    
            }
        }   
            
        function setTail3() {		
            if (reveal3Going && !reveal3Locked) {
                revealArea3.innerHTML = 'You will pick TAIL';
                console.log('Reveal 3 changed to TAIL');
            }
            else {
                console.log('Reveal 3 not changed to TAIL because it is locked');    
            }
        }           
            
        function deleteFinalStuff() {
            if (!finalStuffLocked) {
                finalStuff.innerHTML = '<div class="interaction-box" style="font-size: 4em;">NO</div></div>';
                console.log('Final stuff deleted and replaced with a "NO"');
            }
            else {
                console.log('Final stuff not deleted because it was locked');    
            }
        }            

///////////////////////////////////////////////////////////
// Taking care of loading screens, password screen, etc. //
///////////////////////////////////////////////////////////
	
// Variable to store the wake lock sentinel
let wakeLock = null;

// Function to request a wake lock
async function requestWakeLock() {
    try {
        wakeLock = await navigator.wakeLock.request('screen');
        console.log('Screen wake lock is active!');
        // You might want to add a small visual indicator to the user
        // that screen lock is disabled.
    } catch (err) {
        // The user has denied the request, or the browser doesn't support Wake Lock
        console.error(`${err.name}, ${err.message}`);
    }
}

// Function to release the wake lock (important for good practice)
function releaseWakeLock() {
    if (wakeLock) {
        wakeLock.release();
        wakeLock = null;
        console.log('Screen wake lock is released!');
    }
}

document.addEventListener('visibilitychange', () => {
    if (wakeLock !== null && document.visibilityState === 'hidden') {
        releaseWakeLock();
    }
});

document.addEventListener('beforeunload', () => {
    releaseWakeLock(); // Try to release before the page unloads
});

	
        function handleGenerateClick() {
            
            const enteredPasswordRaw = passwordInput.value;
            const enteredPasswordLower = enteredPasswordRaw.toLowerCase();

	    let fingerMode = false;
	    let seriousMode = false;

	    // Check if "instructions" was entered
            if (enteredPasswordLower.startsWith('instructions')) {
               passwordScreen.style.display = 'none'; // Hide the password screen
               explanationScreen.style.display = 'flex'; // Show the loading screen (using flex for centering)		
	       window.scrollTo({ top: 0, behavior: 'auto' });
            }
		
            // Check if the base password matches
            if (!enteredPasswordLower.startsWith(BASE_PASSWORD)) {
               errorMessage.textContent = 'Incorrect password. Please try again.';
               passwordInput.value = '';
               passwordInput.focus();
               return; // Exit if base password doesn't match
            }
            console.log('pwd entered');
            // Extract the modifier part of the password
            let modifierString = enteredPasswordLower.substring(BASE_PASSWORD.length);

            // --- Parse for "Serious Mode" (s) ---
            if (modifierString.includes('s')) {
                generatingProphecy.innerHTML='Generating Prediction';
                cosmicDataStreams.style.display="none";
                funnyStats.style.display="none";                
                modifierString = modifierString.replace('s', ''); // Remove 's' to easily find numbers
            }

            // --- Parse for "Inverted Mode" (i) ---
            if (modifierString.includes('i')) {
		invertedMode = true;
                revealArea2.innerHTML='You will pick TAIL';         
                modifierString = modifierString.replace('i', ''); // Remove 'i' to easily find numbers
            }		

	    // --- Parse for "Finger Mode" (i) ---
            if (modifierString.includes('f')) {
                fingerMode=true;
                modifierString = modifierString.replace('f', ''); // Remove 'f' to easily find numbers
            }			

            // --- Parse for two-digit number (delay) ---
            const delayMatch = modifierString.match(/\d{2}/); // Regex to find exactly two digits
            if (delayMatch) {
                const potentialDelay = parseInt(delayMatch[0], 10);
                // Check if the number is within the desired range (10-60)
                if (potentialDelay >= 10 && potentialDelay <= 60) {
                    delayTime = potentialDelay * 1000; // Convert seconds to milliseconds
                }
            }

            errorMessage.textContent = ''; // Clear any previous error
            passwordScreen.style.display = 'none'; // Hide the password screen
            loadingScreen.style.display = 'flex'; // Show the loading screen (using flex for centering)
	    window.scrollTo({ top: 0, behavior: 'auto' });
            document.body.style.overflow = 'hidden';

            if (!fingerMode) {
		if (seriousMode) {
		    loadingTitle.innerHTML='Generating Prediction...';
		    loadingText.innerHTML='Please wait';
		}
		else {
                    loadingTitle.innerHTML='Generating Prophecy...';	
		    loadingText.innerHTML='Please wait, our algorithms are analyzing the cosmic data streams';
		}
	        loadingButton.style.visibility='hidden';	         		    
                // Set a timeout to display the prediction content after a delay
                setTimeout(() => {
                    loadingScreen.style.display = 'none'; // Hide the loading screen
                    predictionContent.style.display = 'block'; // Show the prediction content
	            window.scrollTo({ top: 0, behavior: 'auto' });
                    document.body.style.overflow = '';
                    // Request a wake lock when the prediction page is shown
                    requestWakeLock();
                }, 11*1000); // Use the defined delay
	    }
	    else { // finger mode
		const intervalId = setInterval(scanProgressFunction, 100);
	    }
	    loadingBarContainer.visibility   = 'hidden';
	    loadingBar.style.visibility      = 'hidden';
	    loadingSpinner.style.visibility  = 'hidden';
	    loadingProgress.style.visibility = 'hidden';
	    loadingWarning.style.visibility  = 'hidden';   	
            // Request a wake lock when the prediction page is shown
            if ('wakeLock' in navigator) {
                requestWakeLock();
            } else {
                console.warn("Wake Lock API not supported in this browser.");
            }
        }

        // --- Event Listeners ---
        generateButton.addEventListener('click', handleGenerateClick);

        // Allow pressing Enter key in the password field to trigger the button click
        passwordInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                handleGenerateClick();
            }
        });


                


  
                function scanProgressFunction() {
		   scanProgress += 100;
		   const progressPercentage = Math.min(100, Math.floor((scanProgress / (40 * 1000)) * 100));
                   loadingProgress.innerText = `Scan Progress: ${progressPercentage}%`;
                }

	
	////////////////////////////////////
	// Scanning the spectator's brain //
        ////////////////////////////////////


        // --- Configuration ---
        const SCAN_DURATION_SECONDS = 56; // Adjusted to accommodate all messages + extended personality message
        const TEXT_CHANGE_INTERVAL_MS = 4000; // How often scan message changes (4 seconds)
        const FINAL_ANALYSIS_DELAY_MS = 5000; // Delay after scan completes before showing next page
        const MIN_SCAN_DURATION_FOR_WARNING_MS = 500; // If released faster than this, no warning

        // List of funny animals
        const FUNNY_ANIMALS = [
            "Sloth", "Platypus", "Pangolin", "Blobfish", "Tapir",
            "Capybara", "Mole", "Octopus", "Sea Cucumber", "Manatee",
            "Wombat", "Armadillo", "Puffin", "Emu", "Hedgehog",
            "Tuna", "Otter", "Chinchilla", "Alpaca", "Lemur"
        ];

        // Updated and embellished scan messages
        const SCAN_MESSAGES_TEMPLATE = [
            "Establishing connection...",
            "SUCCESS. Downloading memories...",
            "Download Complete (DYNAMIC_GB_SIZE TBytes compressed).",
            "Basic personality analysis started...",
            "Estimated brain volume: DYNAMIC_BRAIN_VOLUME.<br>Personality Type: DYNAMIC_ANIMAL.",
            "Analyzing goals and aspirations...",
            "Assessing weaknesses and limitations...",
            "Trying to establish contact with the deepest layers of the unconscious mind...",
            "Contact established. Successful handshake with the brainstem confirmed.",
            "Analyzing final destiny...", // 10
            "Please hold on as your soul is scanned" // 11 (last, blinking)
        ];

        // The actual messages array that will be used, with duplicates for longer display
        let actualScanMessages = [];

        // --- Scan State Variables ---
        let scanProgress = 0; // Tracks how many milliseconds the button has been held
        let scanIntervalId = null; // ID for the main scan progress timer
        let messageIntervalId = null; // ID for the scan message changer
        let currentMessageIndex = 0;
        let isScanning = false; // Flag to indicate if scan is truly active


            // --- Functions ---

            /**
             * Helper function to prepare messages including dynamic and extended display.
             * This is called once at the start of a scan.
             */
            function prepareScanMessages() {
                actualScanMessages = [];
                const randomTB = getRandomFloat(80.0, 99.9, 1).toFixed(1);
		const randomVolume = getRandomInt(1060, 1499);
                const randomAnimal = FUNNY_ANIMALS[Math.floor(Math.random() * FUNNY_ANIMALS.length)];

                SCAN_MESSAGES_TEMPLATE.forEach((msg, index) => {
                    let processedMsg = msg;
                    if (index === 2) { // GB Size message
                        processedMsg = `Complete (${randomTB} GB compressed).`;
                    } else if (index === 4) { // Personality Type message
                        processedMsg = `Estimated brain volume: <strong>${randomVolume} cm<sup>3</sup></strong><br>Personality Type: <strong>${randomAnimal}</strong>.`;
                    }

                    actualScanMessages.push(processedMsg);

                    // Duplicate the personality message to make it stay longer (e.g., 3 times the normal duration)
                    if (index === 4) {
                        actualScanMessages.push(processedMsg); // Duplicate once
                    }
                });
            }



	
            loadingButton.addEventListener('mousedown', scanButtonDown);
            loadingButton.addEventListener('mouseup', scanButtonUp);
            loadingButton.addEventListener('mouseleave', scanButtonUp); // If mouse leaves while holding
            loadingButton.addEventListener('touchstart', scanButtonUp); // For mobile touch
            loadingButton.addEventListener('touchend', scanButtonUp); // For mobile touch

	

            /**
             * Updates the scan message text and handles the longer last message.
             */
            function updateScanMessage() {
                // Ensure currentMessageIndex does not exceed array bounds
                if (currentMessageIndex >= actualScanMessages.length) {
                    currentMessageIndex = actualScanMessages.length - 1; // Cap it at the last message
                }

                loadingText.innerHTML = actualScanMessages[currentMessageIndex]; // Use innerHTML for bolding

                // If it's the very last message in the *actual* sequence, add the blinking class
                if (currentMessageIndex === actualScanMessages.length - 1) {
                    loadingText.classList.add('blink');
                } else {
                    loadingText.classList.remove('blink');
                }

                // Increment index for the next message
                currentMessageIndex++;
            }

            /**
             * Starts the scanning process when the scan button is pressed.
             */

            function scanButtonDown() {
		scanGoing=true;		    
		scanStarted=true;
		console.log('button down');
		loadingSpinner.style.visibility     = 'visible';
		loadingBarContainer.style.visibility = 'visible';
                loadingBar.style.visibility         = 'visible';
		loadingProgress.style.visibility    = 'visible';
		loadingWarning.style.visibility     = 'hidden';
	    }

	    function scanButtonUp() {
 		scanGoing=false;
		console.log('button up');
		if (scanStarted)
		    loadingWarning.style.visibility = 'visible';
	    }


            function scanProgressFunction() {
    	        if(scanGoing)
		    scanProgress += 100;
		const progressPercentage = Math.min(100, Math.floor((scanProgress / (40 * 1000)) * 100));
                loadingProgress.innerText = `Scan Progress: ${progressPercentage}%`;
            }

	

/*	
            function startScan() {
                // Prevent multiple scan intervals if button is held down again quickly
                if (scanIntervalId !== null) return;

                isScanning = true; // Set scanning flag to true

                scanButton.disabled = true; // Disable button to prevent re-triggering while held

                loadingWarning.style.visibility = 'hidden'; // Hide warning if visible

                // Show the spinner and progress bar container
                loadingSpinner.style.visibility = 'visible'; // Use visibility for spinner
		loadingBarContainer.style.visibility = 'visible';
                loadingBar.style.visibility = 'visible'; // Use visibility for progress bar container
		loadingProgress.style.visibility = 'visible'; // Use visibility for progress bar container
		



                const intervalId = setInterval(scanProgressFunction, 100);


  
                function scanProgressFunction() {
		   scanProgress += 100;
		   const progressPercentage = Math.min(100, Math.floor((scanProgress / (40 * 1000)) * 100));
                   loadingProgress.innerText = `Scan Progress: ${progressPercentage}%`;
                }


            loadingButton.addEventListener('mousedown', startScan);
            loadingButton.addEventListener('mouseup', stopScan);
            loadingButton.addEventListener('mouseleave', stopScan); // If mouse leaves while holding
            loadingButton.addEventListener('touchstart', startScan); // For mobile touch
            loadingButton.addEventListener('touchend', stopScan); // For mobile touch


	
        });*/


















	
});
    </script>
</body>
</html>
